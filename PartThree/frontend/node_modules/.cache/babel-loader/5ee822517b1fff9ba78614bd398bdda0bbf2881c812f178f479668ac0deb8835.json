{"ast":null,"code":"// src/index.ts\nimport { addDomEvent, fireCustomEvent, isContextMenuEvent, queueBeforeEvent as queueBeforeEvent2 } from \"@zag-js/dom-event\";\nimport { contains, getDocument, getEventTarget, getWindow, isFocusable, isHTMLElement, raf } from \"@zag-js/dom-query\";\nimport { callAll } from \"@zag-js/utils\";\n\n// src/get-window-frames.ts\nimport { queueBeforeEvent } from \"@zag-js/dom-event\";\nfunction getWindowFrames(win) {\n  const frames = {\n    each(cb) {\n      for (let i = 0; i < win.frames?.length; i += 1) {\n        const frame = win.frames[i];\n        if (frame) cb(frame);\n      }\n    },\n    queueBeforeEvent(event, listener) {\n      const cleanup = /* @__PURE__ */new Set();\n      frames.each(frame => {\n        try {\n          cleanup.add(queueBeforeEvent(frame.document, event, listener));\n        } catch {}\n      });\n      return () => {\n        try {\n          cleanup.forEach(fn => fn());\n        } catch {}\n      };\n    },\n    addEventListener(event, listener, options) {\n      frames.each(frame => {\n        try {\n          frame.document.addEventListener(event, listener, options);\n        } catch {}\n      });\n      return () => {\n        try {\n          frames.removeEventListener(event, listener, options);\n        } catch {}\n      };\n    },\n    removeEventListener(event, listener, options) {\n      frames.each(frame => {\n        try {\n          frame.document.removeEventListener(event, listener, options);\n        } catch {}\n      });\n    }\n  };\n  return frames;\n}\n\n// src/index.ts\nvar POINTER_OUTSIDE_EVENT = \"pointerdown.outside\";\nvar FOCUS_OUTSIDE_EVENT = \"focus.outside\";\nfunction isComposedPathFocusable(composedPath) {\n  for (const node of composedPath) {\n    if (isHTMLElement(node) && isFocusable(node)) return true;\n  }\n  return false;\n}\nvar isPointerEvent = event => \"clientY\" in event;\nfunction isEventPointWithin(node, event) {\n  if (!isPointerEvent(event) || !node) return false;\n  const rect = node.getBoundingClientRect();\n  if (rect.width === 0 || rect.height === 0) return false;\n  return rect.top <= event.clientY && event.clientY <= rect.top + rect.height && rect.left <= event.clientX && event.clientX <= rect.left + rect.width;\n}\nfunction isEventWithinScrollbar(event) {\n  const target = getEventTarget(event);\n  if (!target || !isPointerEvent(event)) return false;\n  const isScrollableY = target.scrollHeight > target.clientHeight;\n  const onScrollbarY = isScrollableY && event.clientX > target.clientWidth;\n  const isScrollableX = target.scrollWidth > target.clientWidth;\n  const onScrollbarX = isScrollableX && event.clientY > target.clientHeight;\n  return onScrollbarY || onScrollbarX;\n}\nfunction trackInteractOutsideImpl(node, options) {\n  const {\n    exclude,\n    onFocusOutside,\n    onPointerDownOutside,\n    onInteractOutside,\n    defer\n  } = options;\n  if (!node) return;\n  const doc = getDocument(node);\n  const win = getWindow(node);\n  const frames = getWindowFrames(win);\n  function isEventOutside(event) {\n    const target = getEventTarget(event);\n    if (!isHTMLElement(target)) return false;\n    if (contains(node, target)) return false;\n    if (isEventPointWithin(node, event)) return false;\n    if (isEventWithinScrollbar(event)) return false;\n    return !exclude?.(target);\n  }\n  const pointerdownCleanups = /* @__PURE__ */new Set();\n  function onPointerDown(event) {\n    function handler() {\n      const func = defer ? raf : v => v();\n      const composedPath = event.composedPath?.() ?? [event.target];\n      func(() => {\n        if (!node || !isEventOutside(event)) return;\n        if (onPointerDownOutside || onInteractOutside) {\n          const handler2 = callAll(onPointerDownOutside, onInteractOutside);\n          node.addEventListener(POINTER_OUTSIDE_EVENT, handler2, {\n            once: true\n          });\n        }\n        fireCustomEvent(node, POINTER_OUTSIDE_EVENT, {\n          bubbles: false,\n          cancelable: true,\n          detail: {\n            originalEvent: event,\n            contextmenu: isContextMenuEvent(event),\n            focusable: isComposedPathFocusable(composedPath)\n          }\n        });\n      });\n    }\n    if (event.pointerType === \"touch\") {\n      pointerdownCleanups.forEach(fn => fn());\n      pointerdownCleanups.add(queueBeforeEvent2(doc, \"pointerup\", handler));\n      pointerdownCleanups.add(frames.queueBeforeEvent(\"pointerup\", handler));\n    } else {\n      handler();\n    }\n  }\n  const cleanups = /* @__PURE__ */new Set();\n  const timer = setTimeout(() => {\n    cleanups.add(frames.addEventListener(\"pointerdown\", onPointerDown, true));\n    cleanups.add(addDomEvent(doc, \"pointerdown\", onPointerDown, true));\n  }, 0);\n  function onFocusin(event) {\n    const func = defer ? raf : v => v();\n    func(() => {\n      if (!node || !isEventOutside(event)) return;\n      if (onFocusOutside || onInteractOutside) {\n        const handler = callAll(onFocusOutside, onInteractOutside);\n        node.addEventListener(FOCUS_OUTSIDE_EVENT, handler, {\n          once: true\n        });\n      }\n      fireCustomEvent(node, FOCUS_OUTSIDE_EVENT, {\n        bubbles: false,\n        cancelable: true,\n        detail: {\n          originalEvent: event,\n          contextmenu: false,\n          focusable: isFocusable(getEventTarget(event))\n        }\n      });\n    });\n  }\n  cleanups.add(addDomEvent(doc, \"focusin\", onFocusin, true));\n  cleanups.add(frames.addEventListener(\"focusin\", onFocusin, true));\n  return () => {\n    clearTimeout(timer);\n    pointerdownCleanups.forEach(fn => fn());\n    cleanups.forEach(fn => fn());\n  };\n}\nfunction trackInteractOutside(nodeOrFn, options) {\n  const {\n    defer\n  } = options;\n  const func = defer ? raf : v => v();\n  const cleanups = [];\n  cleanups.push(func(() => {\n    const node = typeof nodeOrFn === \"function\" ? nodeOrFn() : nodeOrFn;\n    cleanups.push(trackInteractOutsideImpl(node, options));\n  }));\n  return () => {\n    cleanups.forEach(fn => fn?.());\n  };\n}\nexport { trackInteractOutside };","map":{"version":3,"names":["addDomEvent","fireCustomEvent","isContextMenuEvent","queueBeforeEvent","queueBeforeEvent2","contains","getDocument","getEventTarget","getWindow","isFocusable","isHTMLElement","raf","callAll","getWindowFrames","win","frames","each","cb","i","length","frame","event","listener","cleanup","Set","add","document","forEach","fn","addEventListener","options","removeEventListener","POINTER_OUTSIDE_EVENT","FOCUS_OUTSIDE_EVENT","isComposedPathFocusable","composedPath","node","isPointerEvent","isEventPointWithin","rect","getBoundingClientRect","width","height","top","clientY","left","clientX","isEventWithinScrollbar","target","isScrollableY","scrollHeight","clientHeight","onScrollbarY","clientWidth","isScrollableX","scrollWidth","onScrollbarX","trackInteractOutsideImpl","exclude","onFocusOutside","onPointerDownOutside","onInteractOutside","defer","doc","isEventOutside","pointerdownCleanups","onPointerDown","handler","func","v","handler2","once","bubbles","cancelable","detail","originalEvent","contextmenu","focusable","pointerType","cleanups","timer","setTimeout","onFocusin","clearTimeout","trackInteractOutside","nodeOrFn","push"],"sources":["C:\\Users\\lab_services_student\\Desktop\\PartThree\\frontend\\node_modules\\@zag-js\\interact-outside\\src\\index.ts","C:\\Users\\lab_services_student\\Desktop\\PartThree\\frontend\\node_modules\\@zag-js\\interact-outside\\src\\get-window-frames.ts"],"sourcesContent":["import { addDomEvent, fireCustomEvent, isContextMenuEvent, queueBeforeEvent } from \"@zag-js/dom-event\"\nimport { contains, getDocument, getEventTarget, getWindow, isFocusable, isHTMLElement, raf } from \"@zag-js/dom-query\"\nimport { callAll } from \"@zag-js/utils\"\nimport { getWindowFrames } from \"./get-window-frames\"\n\nexport interface InteractOutsideHandlers {\n  /**\n   * Function called when the pointer is pressed down outside the component\n   */\n  onPointerDownOutside?: (event: PointerDownOutsideEvent) => void\n  /**\n   * Function called when the focus is moved outside the component\n   */\n  onFocusOutside?: (event: FocusOutsideEvent) => void\n  /**\n   * Function called when an interaction happens outside the component\n   */\n  onInteractOutside?: (event: InteractOutsideEvent) => void\n}\n\nexport interface InteractOutsideOptions extends InteractOutsideHandlers {\n  exclude?: (target: HTMLElement) => boolean\n  defer?: boolean\n}\n\nexport interface EventDetails<T> {\n  originalEvent: T\n  contextmenu: boolean\n  focusable: boolean\n}\n\nconst POINTER_OUTSIDE_EVENT = \"pointerdown.outside\"\nconst FOCUS_OUTSIDE_EVENT = \"focus.outside\"\n\nexport type PointerDownOutsideEvent = CustomEvent<EventDetails<PointerEvent>>\n\nexport type FocusOutsideEvent = CustomEvent<EventDetails<FocusEvent>>\n\nexport type InteractOutsideEvent = PointerDownOutsideEvent | FocusOutsideEvent\n\nexport type MaybeElement = HTMLElement | null | undefined\nexport type NodeOrFn = MaybeElement | (() => MaybeElement)\n\nfunction isComposedPathFocusable(composedPath: EventTarget[]) {\n  for (const node of composedPath) {\n    if (isHTMLElement(node) && isFocusable(node)) return true\n  }\n  return false\n}\n\nconst isPointerEvent = (event: Event): event is PointerEvent => \"clientY\" in event\n\nfunction isEventPointWithin(node: MaybeElement, event: Event) {\n  if (!isPointerEvent(event) || !node) return false\n\n  const rect = node.getBoundingClientRect()\n  if (rect.width === 0 || rect.height === 0) return false\n\n  return (\n    rect.top <= event.clientY &&\n    event.clientY <= rect.top + rect.height &&\n    rect.left <= event.clientX &&\n    event.clientX <= rect.left + rect.width\n  )\n}\n\nfunction isEventWithinScrollbar(event: Event): boolean {\n  const target = getEventTarget<HTMLElement>(event)\n  if (!target || !isPointerEvent(event)) return false\n\n  const isScrollableY = target.scrollHeight > target.clientHeight\n  const onScrollbarY = isScrollableY && event.clientX > target.clientWidth\n\n  const isScrollableX = target.scrollWidth > target.clientWidth\n  const onScrollbarX = isScrollableX && event.clientY > target.clientHeight\n\n  return onScrollbarY || onScrollbarX\n}\n\nfunction trackInteractOutsideImpl(node: MaybeElement, options: InteractOutsideOptions) {\n  const { exclude, onFocusOutside, onPointerDownOutside, onInteractOutside, defer } = options\n\n  if (!node) return\n\n  const doc = getDocument(node)\n  const win = getWindow(node)\n  const frames = getWindowFrames(win)\n\n  function isEventOutside(event: Event): boolean {\n    const target = getEventTarget(event)\n    if (!isHTMLElement(target)) return false\n    if (contains(node, target)) return false\n    if (isEventPointWithin(node, event)) return false\n    if (isEventWithinScrollbar(event)) return false\n    return !exclude?.(target)\n  }\n\n  const pointerdownCleanups: Set<VoidFunction> = new Set()\n\n  function onPointerDown(event: PointerEvent) {\n    //\n    function handler() {\n      const func = defer ? raf : (v: any) => v()\n      const composedPath = event.composedPath?.() ?? [event.target]\n      func(() => {\n        if (!node || !isEventOutside(event)) return\n\n        if (onPointerDownOutside || onInteractOutside) {\n          const handler = callAll(onPointerDownOutside, onInteractOutside) as EventListener\n          node.addEventListener(POINTER_OUTSIDE_EVENT, handler, { once: true })\n        }\n\n        fireCustomEvent(node, POINTER_OUTSIDE_EVENT, {\n          bubbles: false,\n          cancelable: true,\n          detail: {\n            originalEvent: event,\n            contextmenu: isContextMenuEvent(event),\n            focusable: isComposedPathFocusable(composedPath),\n          },\n        })\n      })\n    }\n\n    if (event.pointerType === \"touch\") {\n      // flush any pending pointerup events\n      pointerdownCleanups.forEach((fn) => fn())\n\n      // add a pointerup event listener to the document and all frame documents\n      pointerdownCleanups.add(queueBeforeEvent(doc, \"pointerup\", handler))\n      pointerdownCleanups.add(frames.queueBeforeEvent(\"pointerup\", handler))\n    } else {\n      handler()\n    }\n  }\n  const cleanups = new Set<VoidFunction>()\n\n  const timer = setTimeout(() => {\n    cleanups.add(frames.addEventListener(\"pointerdown\", onPointerDown, true))\n    cleanups.add(addDomEvent(doc, \"pointerdown\", onPointerDown, true))\n  }, 0)\n\n  function onFocusin(event: FocusEvent) {\n    //\n    const func = defer ? raf : (v: any) => v()\n    func(() => {\n      if (!node || !isEventOutside(event)) return\n\n      if (onFocusOutside || onInteractOutside) {\n        const handler = callAll(onFocusOutside, onInteractOutside) as EventListener\n        node.addEventListener(FOCUS_OUTSIDE_EVENT, handler, { once: true })\n      }\n\n      fireCustomEvent(node, FOCUS_OUTSIDE_EVENT, {\n        bubbles: false,\n        cancelable: true,\n        detail: {\n          originalEvent: event,\n          contextmenu: false,\n          focusable: isFocusable(getEventTarget(event)),\n        },\n      })\n    })\n  }\n\n  cleanups.add(addDomEvent(doc, \"focusin\", onFocusin, true))\n  cleanups.add(frames.addEventListener(\"focusin\", onFocusin, true))\n\n  return () => {\n    clearTimeout(timer)\n    pointerdownCleanups.forEach((fn) => fn())\n    cleanups.forEach((fn) => fn())\n  }\n}\n\nexport function trackInteractOutside(nodeOrFn: NodeOrFn, options: InteractOutsideOptions) {\n  const { defer } = options\n  const func = defer ? raf : (v: any) => v()\n  const cleanups: (VoidFunction | undefined)[] = []\n  cleanups.push(\n    func(() => {\n      const node = typeof nodeOrFn === \"function\" ? nodeOrFn() : nodeOrFn\n      cleanups.push(trackInteractOutsideImpl(node, options))\n    }),\n  )\n  return () => {\n    cleanups.forEach((fn) => fn?.())\n  }\n}\n","import { queueBeforeEvent } from \"@zag-js/dom-event\"\n\nexport function getWindowFrames(win: Window) {\n  const frames = {\n    each(cb: (win: Window) => void) {\n      for (let i = 0; i < win.frames?.length; i += 1) {\n        const frame = win.frames[i]\n        if (frame) cb(frame)\n      }\n    },\n\n    queueBeforeEvent(event: string, listener: any) {\n      const cleanup = new Set<VoidFunction>()\n      frames.each((frame) => {\n        try {\n          cleanup.add(queueBeforeEvent(frame.document, event, listener))\n        } catch {}\n      })\n\n      return () => {\n        try {\n          cleanup.forEach((fn) => fn())\n        } catch {}\n      }\n    },\n\n    addEventListener(event: string, listener: any, options?: any) {\n      frames.each((frame) => {\n        try {\n          frame.document.addEventListener(event, listener, options)\n        } catch {}\n      })\n\n      return () => {\n        try {\n          frames.removeEventListener(event, listener, options)\n        } catch {}\n      }\n    },\n\n    removeEventListener(event: string, listener: any, options?: any) {\n      frames.each((frame) => {\n        try {\n          frame.document.removeEventListener(event, listener, options)\n        } catch {}\n      })\n    },\n  }\n\n  return frames\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
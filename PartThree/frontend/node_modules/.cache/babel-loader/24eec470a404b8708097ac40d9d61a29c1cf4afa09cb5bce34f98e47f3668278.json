{"ast":null,"code":"// src/index.ts\nfunction getMinValueAtIndex(index, values, minValue) {\n  return index === 0 ? minValue : values[index - 1];\n}\nfunction getMaxValueAtIndex(index, values, maxValue) {\n  return index === values.length - 1 ? maxValue : values[index + 1];\n}\nfunction isValueAtMax(value, maxValue) {\n  return value >= maxValue;\n}\nfunction isValueAtMin(value, minValue) {\n  return value <= minValue;\n}\nfunction isValueWithinRange(value, minValue, maxValue) {\n  return value >= minValue && value <= maxValue;\n}\nfunction getRoundedValue(value, minValue, step) {\n  return Math.round((value - minValue) / step) * step + minValue;\n}\nfunction clampValue(value, minValue, maxValue) {\n  return Math.min(Math.max(value, minValue), maxValue);\n}\nfunction getValuePercent(value, minValue, maxValue) {\n  return (value - minValue) / (maxValue - minValue);\n}\nfunction getPercentValue(percent, minValue, maxValue, step) {\n  const value = percent * (maxValue - minValue) + minValue;\n  const roundedValue = getRoundedValue(value, minValue, step);\n  return clampValue(roundedValue, minValue, maxValue);\n}\nfunction roundToStepPrecision(value, step) {\n  let roundedValue = value;\n  let stepString = step.toString();\n  let pointIndex = stepString.indexOf(\".\");\n  let precision = pointIndex >= 0 ? stepString.length - pointIndex : 0;\n  if (precision > 0) {\n    let pow = Math.pow(10, precision);\n    roundedValue = Math.round(roundedValue * pow) / pow;\n  }\n  return roundedValue;\n}\nfunction snapValueToStep(value, min, max, step) {\n  min = Number(min);\n  max = Number(max);\n  let remainder = (value - (isNaN(min) ? 0 : min)) % step;\n  let snappedValue = roundToStepPrecision(Math.abs(remainder) * 2 >= step ? value + Math.sign(remainder) * (step - Math.abs(remainder)) : value - remainder, step);\n  if (!isNaN(min)) {\n    if (snappedValue < min) {\n      snappedValue = min;\n    } else if (!isNaN(max) && snappedValue > max) {\n      snappedValue = min + Math.floor(roundToStepPrecision((max - min) / step, step)) * step;\n    }\n  } else if (!isNaN(max) && snappedValue > max) {\n    snappedValue = Math.floor(roundToStepPrecision(max / step, step)) * step;\n  }\n  snappedValue = roundToStepPrecision(snappedValue, step);\n  return snappedValue;\n}\nfunction setValueAtIndex(values, index, value) {\n  if (values[index] === value) return values;\n  return [...values.slice(0, index), value, ...values.slice(index + 1)];\n}\nfunction getValueSetterAtIndex(index, ctx) {\n  const minValueAtIndex = getMinValueAtIndex(index, ctx.values, ctx.min);\n  const maxValueAtIndex = getMaxValueAtIndex(index, ctx.values, ctx.max);\n  let nextValues = ctx.values.slice();\n  return function setValue(value) {\n    let nextValue = snapValueToStep(value, minValueAtIndex, maxValueAtIndex, ctx.step);\n    nextValues = setValueAtIndex(nextValues, index, value);\n    nextValues[index] = nextValue;\n    return nextValues;\n  };\n}\nfunction getNextStepValue(index, ctx) {\n  const nextValue = ctx.values[index] + ctx.step;\n  return getValueSetterAtIndex(index, ctx)(nextValue);\n}\nfunction getPreviousStepValue(index, ctx) {\n  const nextValue = ctx.values[index] - ctx.step;\n  return getValueSetterAtIndex(index, ctx)(nextValue);\n}\nfunction getClosestValueIndex(values, targetValue) {\n  let targetIndex = values.findIndex(value => targetValue - value < 0);\n  if (targetIndex === 0) {\n    return targetIndex;\n  }\n  if (targetIndex === -1) {\n    return values.length - 1;\n  }\n  let valueBefore = values[targetIndex - 1];\n  let valueAfter = values[targetIndex];\n  if (Math.abs(valueBefore - targetValue) < Math.abs(valueAfter - targetValue)) {\n    return targetIndex - 1;\n  }\n  return targetIndex;\n}\nfunction getValueRanges(values, minValue, maxValue, gap) {\n  return values.map((value, index) => {\n    const min = index === 0 ? minValue : values[index - 1] + gap;\n    const max = index === values.length - 1 ? maxValue : values[index + 1] - gap;\n    return {\n      min,\n      max,\n      value\n    };\n  });\n}\nfunction getValueTransformer(valueA, valueB) {\n  const input = {\n    min: valueA[0],\n    max: valueA[1]\n  };\n  const output = {\n    min: valueB[0],\n    max: valueB[1]\n  };\n  return function getValue(value) {\n    if (input.min === input.max || output.min === output.max) return output.min;\n    const ratio = (output.max - output.min) / (input.max - input.min);\n    return output.min + ratio * (value - input.min);\n  };\n}\nfunction toFixedNumber(value, digits = 0, base = 10) {\n  const pow = Math.pow(base, digits);\n  return Math.round(value * pow) / pow;\n}\nfunction mod(value, modulo) {\n  return (value % modulo + modulo) % modulo;\n}\nexport { clampValue, getClosestValueIndex, getMaxValueAtIndex, getMinValueAtIndex, getNextStepValue, getPercentValue, getPreviousStepValue, getRoundedValue, getValuePercent, getValueRanges, getValueSetterAtIndex, getValueTransformer, isValueAtMax, isValueAtMin, isValueWithinRange, mod, roundToStepPrecision, snapValueToStep, toFixedNumber };","map":{"version":3,"names":["getMinValueAtIndex","index","values","minValue","getMaxValueAtIndex","maxValue","length","isValueAtMax","value","isValueAtMin","isValueWithinRange","getRoundedValue","step","Math","round","clampValue","min","max","getValuePercent","getPercentValue","percent","roundedValue","roundToStepPrecision","stepString","toString","pointIndex","indexOf","precision","pow","snapValueToStep","Number","remainder","isNaN","snappedValue","abs","sign","floor","setValueAtIndex","slice","getValueSetterAtIndex","ctx","minValueAtIndex","maxValueAtIndex","nextValues","setValue","nextValue","getNextStepValue","getPreviousStepValue","getClosestValueIndex","targetValue","targetIndex","findIndex","valueBefore","valueAfter","getValueRanges","gap","map","getValueTransformer","valueA","valueB","input","output","getValue","ratio","toFixedNumber","digits","base","mod","modulo"],"sources":["C:\\Users\\lab_services_student\\Desktop\\PartThree\\frontend\\node_modules\\@zag-js\\numeric-range\\src\\index.ts"],"sourcesContent":["export function getMinValueAtIndex(index: number, values: number[], minValue: number) {\n  return index === 0 ? minValue : values[index - 1]\n}\n\nexport function getMaxValueAtIndex(index: number, values: number[], maxValue: number) {\n  return index === values.length - 1 ? maxValue : values[index + 1]\n}\n\nexport function isValueAtMax(value: number, maxValue: number) {\n  return value >= maxValue\n}\n\nexport function isValueAtMin(value: number, minValue: number) {\n  return value <= minValue\n}\n\nexport function isValueWithinRange(value: number, minValue: number, maxValue: number) {\n  return value >= minValue && value <= maxValue\n}\n\nexport function getRoundedValue(value: number, minValue: number, step: number) {\n  return Math.round((value - minValue) / step) * step + minValue\n}\n\nexport function clampValue(value: number, minValue: number, maxValue: number) {\n  return Math.min(Math.max(value, minValue), maxValue)\n}\n\nexport function getValuePercent(value: number, minValue: number, maxValue: number) {\n  return (value - minValue) / (maxValue - minValue)\n}\n\nexport function getPercentValue(percent: number, minValue: number, maxValue: number, step: number) {\n  const value = percent * (maxValue - minValue) + minValue\n  const roundedValue = getRoundedValue(value, minValue, step)\n  return clampValue(roundedValue, minValue, maxValue)\n}\n\nexport function roundToStepPrecision(value: number, step: number) {\n  let roundedValue = value\n  let stepString = step.toString()\n  let pointIndex = stepString.indexOf(\".\")\n  let precision = pointIndex >= 0 ? stepString.length - pointIndex : 0\n  if (precision > 0) {\n    let pow = Math.pow(10, precision)\n    roundedValue = Math.round(roundedValue * pow) / pow\n  }\n  return roundedValue\n}\n\nexport function snapValueToStep(value: number, min: number | undefined, max: number | undefined, step: number): number {\n  min = Number(min)\n  max = Number(max)\n  let remainder = (value - (isNaN(min) ? 0 : min)) % step\n  let snappedValue = roundToStepPrecision(\n    Math.abs(remainder) * 2 >= step ? value + Math.sign(remainder) * (step - Math.abs(remainder)) : value - remainder,\n    step,\n  )\n\n  if (!isNaN(min)) {\n    if (snappedValue < min) {\n      snappedValue = min\n    } else if (!isNaN(max) && snappedValue > max) {\n      snappedValue = min + Math.floor(roundToStepPrecision((max - min) / step, step)) * step\n    }\n  } else if (!isNaN(max) && snappedValue > max) {\n    snappedValue = Math.floor(roundToStepPrecision(max / step, step)) * step\n  }\n\n  // correct floating point behavior by rounding to step precision\n  snappedValue = roundToStepPrecision(snappedValue, step)\n\n  return snappedValue\n}\n\nfunction setValueAtIndex<T>(values: T[], index: number, value: T) {\n  if (values[index] === value) return values\n  return [...values.slice(0, index), value, ...values.slice(index + 1)]\n}\n\ntype RangeContext = {\n  min: number\n  max: number\n  step: number\n  values: number[]\n}\n\nexport function getValueSetterAtIndex(index: number, ctx: RangeContext) {\n  const minValueAtIndex = getMinValueAtIndex(index, ctx.values, ctx.min)\n  const maxValueAtIndex = getMaxValueAtIndex(index, ctx.values, ctx.max)\n  let nextValues = ctx.values.slice()\n\n  return function setValue(value: number) {\n    let nextValue = snapValueToStep(value, minValueAtIndex, maxValueAtIndex, ctx.step)\n    nextValues = setValueAtIndex(nextValues, index, value)\n    nextValues[index] = nextValue\n    return nextValues\n  }\n}\n\nexport function getNextStepValue(index: number, ctx: RangeContext) {\n  const nextValue = ctx.values[index] + ctx.step\n  return getValueSetterAtIndex(index, ctx)(nextValue)\n}\n\nexport function getPreviousStepValue(index: number, ctx: RangeContext) {\n  const nextValue = ctx.values[index] - ctx.step\n  return getValueSetterAtIndex(index, ctx)(nextValue)\n}\n\nexport function getClosestValueIndex(values: number[], targetValue: number) {\n  let targetIndex = values.findIndex((value) => targetValue - value < 0)\n\n  // If the index is zero then the closetThumb is the first one\n  if (targetIndex === 0) {\n    return targetIndex\n  }\n\n  // If no index is found they've clicked past all the thumbs\n  if (targetIndex === -1) {\n    return values.length - 1\n  }\n\n  let valueBefore = values[targetIndex - 1]\n  let valueAfter = values[targetIndex]\n\n  // Pick the last left/start thumb, unless they are stacked on top of each other, then pick the right/end one\n  if (Math.abs(valueBefore - targetValue) < Math.abs(valueAfter - targetValue)) {\n    return targetIndex - 1\n  }\n\n  return targetIndex\n}\n\nexport function getValueRanges(values: number[], minValue: number, maxValue: number, gap: number) {\n  return values.map((value, index) => {\n    const min = index === 0 ? minValue : values[index - 1] + gap\n    const max = index === values.length - 1 ? maxValue : values[index + 1] - gap\n    return { min, max, value }\n  })\n}\n\nexport function getValueTransformer(valueA: number[], valueB: number[]) {\n  const input = { min: valueA[0], max: valueA[1] }\n  const output = { min: valueB[0], max: valueB[1] }\n\n  return function getValue(value: number) {\n    if (input.min === input.max || output.min === output.max) return output.min\n    const ratio = (output.max - output.min) / (input.max - input.min)\n    return output.min + ratio * (value - input.min)\n  }\n}\n\nexport function toFixedNumber(value: number, digits = 0, base: number = 10): number {\n  const pow = Math.pow(base, digits)\n  return Math.round(value * pow) / pow\n}\n\nexport function mod(value: number, modulo: number) {\n  return ((value % modulo) + modulo) % modulo\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
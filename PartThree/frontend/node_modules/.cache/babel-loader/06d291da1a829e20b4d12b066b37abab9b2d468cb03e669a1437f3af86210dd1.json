{"ast":null,"code":"// src/index.ts\nvar rafId;\nvar observedElements = /* @__PURE__ */new Map();\nvar getRectFn = el => el.getBoundingClientRect();\nfunction trackElementRect(el, options) {\n  const {\n    scope = \"rect\",\n    getRect = getRectFn,\n    onChange\n  } = options;\n  const loop = getLoopFn({\n    scope,\n    getRect\n  });\n  const data = observedElements.get(el);\n  if (!data) {\n    observedElements.set(el, {\n      rect: {},\n      callbacks: [onChange]\n    });\n    if (observedElements.size === 1) {\n      rafId = requestAnimationFrame(loop);\n    }\n  } else {\n    data.callbacks.push(onChange);\n    onChange(getRect(el));\n  }\n  return function unobserve() {\n    const data2 = observedElements.get(el);\n    if (!data2) return;\n    const index = data2.callbacks.indexOf(onChange);\n    if (index > -1) {\n      data2.callbacks.splice(index, 1);\n    }\n    if (data2.callbacks.length === 0) {\n      observedElements.delete(el);\n      if (observedElements.size === 0) {\n        cancelAnimationFrame(rafId);\n      }\n    }\n  };\n}\nfunction getLoopFn(options) {\n  const {\n    scope,\n    getRect\n  } = options;\n  const isEqual = getEqualityFn(scope);\n  return function loop() {\n    const changedRectsData = [];\n    observedElements.forEach((data, element) => {\n      const newRect = getRect(element);\n      if (!isEqual(data.rect, newRect)) {\n        data.rect = newRect;\n        changedRectsData.push(data);\n      }\n    });\n    changedRectsData.forEach(data => {\n      data.callbacks.forEach(callback => callback(data.rect));\n    });\n    rafId = requestAnimationFrame(loop);\n  };\n}\nvar isEqualSize = (a, b) => a.width === b.width && a.height === b.height;\nvar isEqualPosition = (a, b) => a.top === b.top && a.left === b.left;\nvar isEqualRect = (a, b) => isEqualSize(a, b) && isEqualPosition(a, b);\nfunction getEqualityFn(scope) {\n  if (scope === \"size\") return isEqualSize;\n  if (scope === \"position\") return isEqualPosition;\n  return isEqualRect;\n}\nexport { trackElementRect };","map":{"version":3,"names":["rafId","observedElements","Map","getRectFn","el","getBoundingClientRect","trackElementRect","options","scope","getRect","onChange","loop","getLoopFn","data","get","set","rect","callbacks","size","requestAnimationFrame","push","unobserve","data2","index","indexOf","splice","length","delete","cancelAnimationFrame","isEqual","getEqualityFn","changedRectsData","forEach","element","newRect","callback","isEqualSize","a","b","width","height","isEqualPosition","top","left","isEqualRect"],"sources":["C:\\Users\\lab_services_student\\Desktop\\PartThree\\frontend\\node_modules\\@zag-js\\element-rect\\src\\index.ts"],"sourcesContent":["type Fn = (rect: Rect) => void\n\ninterface Rect {\n  top: number\n  left: number\n  width: number\n  height: number\n}\n\ninterface ObservedData {\n  rect: Rect\n  callbacks: Fn[]\n}\n\nlet rafId: number\n\nconst observedElements = new Map<HTMLElement, ObservedData>()\n\ntype TrackScope = \"size\" | \"position\" | \"rect\"\n\nexport type ElementRectOptions = {\n  onChange: (rect: Rect) => void\n  scope?: TrackScope\n  getRect?: (el: HTMLElement) => Rect\n}\n\nconst getRectFn = (el: HTMLElement) => el.getBoundingClientRect()\n\nexport function trackElementRect(el: HTMLElement, options: ElementRectOptions) {\n  const { scope = \"rect\", getRect = getRectFn, onChange } = options\n  const loop = getLoopFn({ scope, getRect })\n\n  const data = observedElements.get(el)\n\n  if (!data) {\n    observedElements.set(el, {\n      rect: {} as Rect,\n      callbacks: [onChange],\n    })\n\n    if (observedElements.size === 1) {\n      rafId = requestAnimationFrame(loop)\n    }\n  } else {\n    data.callbacks.push(onChange)\n    onChange(getRect(el))\n  }\n\n  return function unobserve() {\n    const data = observedElements.get(el)\n    if (!data) return\n\n    const index = data.callbacks.indexOf(onChange)\n    if (index > -1) {\n      data.callbacks.splice(index, 1)\n    }\n\n    if (data.callbacks.length === 0) {\n      observedElements.delete(el)\n\n      if (observedElements.size === 0) {\n        cancelAnimationFrame(rafId)\n      }\n    }\n  }\n}\n\nfunction getLoopFn(options: Required<Omit<ElementRectOptions, \"onChange\">>) {\n  const { scope, getRect } = options\n  const isEqual = getEqualityFn(scope)\n  return function loop() {\n    const changedRectsData: Array<ObservedData> = []\n\n    observedElements.forEach((data, element) => {\n      const newRect = getRect(element)\n\n      if (!isEqual(data.rect, newRect)) {\n        data.rect = newRect\n        changedRectsData.push(data)\n      }\n    })\n\n    changedRectsData.forEach((data) => {\n      data.callbacks.forEach((callback) => callback(data.rect))\n    })\n\n    rafId = requestAnimationFrame(loop)\n  }\n}\n\nconst isEqualSize = (a: Rect, b: Rect) => a.width === b.width && a.height === b.height\n\nconst isEqualPosition = (a: Rect, b: Rect) => a.top === b.top && a.left === b.left\n\nconst isEqualRect = (a: Rect, b: Rect) => isEqualSize(a, b) && isEqualPosition(a, b)\n\nfunction getEqualityFn(scope: TrackScope) {\n  if (scope === \"size\") return isEqualSize\n  if (scope === \"position\") return isEqualPosition\n  return isEqualRect\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n\n// src/color-format-gradient.ts\nvar generateRGB_R = (orientation, dir, zValue) => {\n  const maskImage = `linear-gradient(to ${orientation[Number(!dir)]}, transparent, #000)`;\n  const result = {\n    areaStyles: {\n      backgroundImage: `linear-gradient(to ${orientation[Number(dir)]},rgb(${zValue},0,0),rgb(${zValue},255,0))`\n    },\n    areaGradientStyles: {\n      backgroundImage: `linear-gradient(to ${orientation[Number(dir)]},rgb(${zValue},0,255),rgb(${zValue},255,255))`,\n      WebkitMaskImage: maskImage,\n      maskImage\n    }\n  };\n  return result;\n};\nvar generateRGB_G = (orientation, dir, zValue) => {\n  const maskImage = `linear-gradient(to ${orientation[Number(!dir)]}, transparent, #000)`;\n  const result = {\n    areaStyles: {\n      backgroundImage: `linear-gradient(to ${orientation[Number(dir)]},rgb(0,${zValue},0),rgb(255,${zValue},0))`\n    },\n    areaGradientStyles: {\n      backgroundImage: `linear-gradient(to ${orientation[Number(dir)]},rgb(0,${zValue},255),rgb(255,${zValue},255))`,\n      WebkitMaskImage: maskImage,\n      maskImage\n    }\n  };\n  return result;\n};\nvar generateRGB_B = (orientation, dir, zValue) => {\n  const maskImage = `linear-gradient(to ${orientation[Number(!dir)]}, transparent, #000)`;\n  const result = {\n    areaStyles: {\n      backgroundImage: `linear-gradient(to ${orientation[Number(dir)]},rgb(0,0,${zValue}),rgb(255,0,${zValue}))`\n    },\n    areaGradientStyles: {\n      backgroundImage: `linear-gradient(to ${orientation[Number(dir)]},rgb(0,255,${zValue}),rgb(255,255,${zValue}))`,\n      WebkitMaskImage: maskImage,\n      maskImage\n    }\n  };\n  return result;\n};\nvar generateHSL_H = (orientation, dir, zValue) => {\n  const result = {\n    areaStyles: {},\n    areaGradientStyles: {\n      background: [`linear-gradient(to ${orientation[Number(dir)]}, hsla(0,0%,0%,1) 0%, hsla(0,0%,0%,0) 50%, hsla(0,0%,100%,0) 50%, hsla(0,0%,100%,1) 100%)`, `linear-gradient(to ${orientation[Number(!dir)]},hsl(0,0%,50%),hsla(0,0%,50%,0))`, `hsl(${zValue}, 100%, 50%)`].join(\",\")\n    }\n  };\n  return result;\n};\nvar generateHSL_S = (orientation, dir, alphaValue) => {\n  const result = {\n    areaStyles: {},\n    areaGradientStyles: {\n      background: [`linear-gradient(to ${orientation[Number(!dir)]}, hsla(0,0%,0%,${alphaValue}) 0%, hsla(0,0%,0%,0) 50%, hsla(0,0%,100%,0) 50%, hsla(0,0%,100%,${alphaValue}) 100%)`, `linear-gradient(to ${orientation[Number(dir)]},hsla(0,100%,50%,${alphaValue}),hsla(60,100%,50%,${alphaValue}),hsla(120,100%,50%,${alphaValue}),hsla(180,100%,50%,${alphaValue}),hsla(240,100%,50%,${alphaValue}),hsla(300,100%,50%,${alphaValue}),hsla(359,100%,50%,${alphaValue}))`, \"hsl(0, 0%, 50%)\"].join(\",\")\n    }\n  };\n  return result;\n};\nvar generateHSL_L = (orientation, dir, zValue) => {\n  const result = {\n    areaStyles: {},\n    areaGradientStyles: {\n      backgroundImage: [`linear-gradient(to ${orientation[Number(!dir)]},hsl(0,0%,${zValue}%),hsla(0,0%,${zValue}%,0))`, `linear-gradient(to ${orientation[Number(dir)]},hsl(0,100%,${zValue}%),hsl(60,100%,${zValue}%),hsl(120,100%,${zValue}%),hsl(180,100%,${zValue}%),hsl(240,100%,${zValue}%),hsl(300,100%,${zValue}%),hsl(360,100%,${zValue}%))`].join(\",\")\n    }\n  };\n  return result;\n};\nvar generateHSB_H = (orientation, dir, zValue) => {\n  const result = {\n    areaStyles: {},\n    areaGradientStyles: {\n      background: [`linear-gradient(to ${orientation[Number(dir)]},hsl(0,0%,0%),hsla(0,0%,0%,0))`, `linear-gradient(to ${orientation[Number(!dir)]},hsl(0,0%,100%),hsla(0,0%,100%,0))`, `hsl(${zValue}, 100%, 50%)`].join(\",\")\n    }\n  };\n  return result;\n};\nvar generateHSB_S = (orientation, dir, alphaValue) => {\n  const result = {\n    areaStyles: {},\n    areaGradientStyles: {\n      background: [`linear-gradient(to ${orientation[Number(!dir)]},hsla(0,0%,0%,${alphaValue}),hsla(0,0%,0%,0))`, `linear-gradient(to ${orientation[Number(dir)]},hsla(0,100%,50%,${alphaValue}),hsla(60,100%,50%,${alphaValue}),hsla(120,100%,50%,${alphaValue}),hsla(180,100%,50%,${alphaValue}),hsla(240,100%,50%,${alphaValue}),hsla(300,100%,50%,${alphaValue}),hsla(359,100%,50%,${alphaValue}))`, `linear-gradient(to ${orientation[Number(!dir)]},hsl(0,0%,0%),hsl(0,0%,100%))`].join(\",\")\n    }\n  };\n  return result;\n};\nvar generateHSB_B = (orientation, dir, alphaValue) => {\n  const result = {\n    areaStyles: {},\n    areaGradientStyles: {\n      background: [`linear-gradient(to ${orientation[Number(!dir)]},hsla(0,0%,100%,${alphaValue}),hsla(0,0%,100%,0))`, `linear-gradient(to ${orientation[Number(dir)]},hsla(0,100%,50%,${alphaValue}),hsla(60,100%,50%,${alphaValue}),hsla(120,100%,50%,${alphaValue}),hsla(180,100%,50%,${alphaValue}),hsla(240,100%,50%,${alphaValue}),hsla(300,100%,50%,${alphaValue}),hsla(359,100%,50%,${alphaValue}))`, \"#000\"].join(\",\")\n    }\n  };\n  return result;\n};\n\n// src/area-gradient.ts\nfunction getColorAreaGradient(color, options) {\n  const {\n    xChannel,\n    yChannel,\n    dir: dirProp = \"ltr\"\n  } = options;\n  const {\n    zChannel\n  } = color.getColorAxes({\n    xChannel,\n    yChannel\n  });\n  const zValue = color.getChannelValue(zChannel);\n  const {\n    minValue: zMin,\n    maxValue: zMax\n  } = color.getChannelRange(zChannel);\n  const orientation = [\"top\", dirProp === \"rtl\" ? \"left\" : \"right\"];\n  let dir = false;\n  let background = {\n    areaStyles: {},\n    areaGradientStyles: {}\n  };\n  let alphaValue = (zValue - zMin) / (zMax - zMin);\n  let isHSL = color.getFormat() === \"hsla\";\n  switch (zChannel) {\n    case \"red\":\n      {\n        dir = xChannel === \"green\";\n        background = generateRGB_R(orientation, dir, zValue);\n        break;\n      }\n    case \"green\":\n      {\n        dir = xChannel === \"red\";\n        background = generateRGB_G(orientation, dir, zValue);\n        break;\n      }\n    case \"blue\":\n      {\n        dir = xChannel === \"red\";\n        background = generateRGB_B(orientation, dir, zValue);\n        break;\n      }\n    case \"hue\":\n      {\n        dir = xChannel !== \"saturation\";\n        if (isHSL) {\n          background = generateHSL_H(orientation, dir, zValue);\n        } else {\n          background = generateHSB_H(orientation, dir, zValue);\n        }\n        break;\n      }\n    case \"saturation\":\n      {\n        dir = xChannel === \"hue\";\n        if (isHSL) {\n          background = generateHSL_S(orientation, dir, alphaValue);\n        } else {\n          background = generateHSB_S(orientation, dir, alphaValue);\n        }\n        break;\n      }\n    case \"brightness\":\n      {\n        dir = xChannel === \"hue\";\n        background = generateHSB_B(orientation, dir, alphaValue);\n        break;\n      }\n    case \"lightness\":\n      {\n        dir = xChannel === \"hue\";\n        background = generateHSL_L(orientation, dir, zValue);\n        break;\n      }\n  }\n  return background;\n}\n\n// src/color.ts\nimport { clampValue, getPercentValue, getValuePercent, snapValueToStep } from \"@zag-js/numeric-range\";\nvar isEqualObject = (a, b) => {\n  if (Object.keys(a).length !== Object.keys(b).length) return false;\n  for (let key in a) if (a[key] !== b[key]) return false;\n  return true;\n};\nvar Color = class {\n  toHexInt() {\n    return this.toFormat(\"rgba\").toHexInt();\n  }\n  getChannelValue(channel) {\n    if (channel in this) return this[channel];\n    throw new Error(\"Unsupported color channel: \" + channel);\n  }\n  getChannelValuePercent(channel, valueToCheck) {\n    const value = valueToCheck ?? this.getChannelValue(channel);\n    const {\n      minValue,\n      maxValue\n    } = this.getChannelRange(channel);\n    return getValuePercent(value, minValue, maxValue);\n  }\n  getChannelPercentValue(channel, percentToCheck) {\n    const {\n      minValue,\n      maxValue,\n      step\n    } = this.getChannelRange(channel);\n    const percentValue = getPercentValue(percentToCheck, minValue, maxValue, step);\n    return snapValueToStep(percentValue, minValue, maxValue, step);\n  }\n  withChannelValue(channel, value) {\n    const {\n      minValue,\n      maxValue\n    } = this.getChannelRange(channel);\n    if (channel in this) {\n      let clone = this.clone();\n      clone[channel] = clampValue(value, minValue, maxValue);\n      return clone;\n    }\n    throw new Error(\"Unsupported color channel: \" + channel);\n  }\n  getColorAxes(xyChannels) {\n    let {\n      xChannel,\n      yChannel\n    } = xyChannels;\n    let xCh = xChannel || this.getChannels().find(c => c !== yChannel);\n    let yCh = yChannel || this.getChannels().find(c => c !== xCh);\n    let zCh = this.getChannels().find(c => c !== xCh && c !== yCh);\n    return {\n      xChannel: xCh,\n      yChannel: yCh,\n      zChannel: zCh\n    };\n  }\n  incrementChannel(channel, stepSize) {\n    const {\n      minValue,\n      maxValue,\n      step\n    } = this.getChannelRange(channel);\n    const value = snapValueToStep(clampValue(this.getChannelValue(channel) + stepSize, minValue, maxValue), minValue, maxValue, step);\n    return this.withChannelValue(channel, value);\n  }\n  decrementChannel(channel, stepSize) {\n    return this.incrementChannel(channel, -stepSize);\n  }\n  isEqual(color) {\n    const isSame = isEqualObject(this.toJSON(), color.toJSON());\n    return isSame && this.getChannelValue(\"alpha\") === color.getChannelValue(\"alpha\");\n  }\n};\n\n// src/hsb-color.ts\nimport { clampValue as clampValue4, mod as mod2, toFixedNumber as toFixedNumber3 } from \"@zag-js/numeric-range\";\n\n// src/hsl-color.ts\nimport { clampValue as clampValue3, mod, toFixedNumber as toFixedNumber2 } from \"@zag-js/numeric-range\";\n\n// src/rgb-color.ts\nimport { clampValue as clampValue2, toFixedNumber } from \"@zag-js/numeric-range\";\nvar _RGBColor = class _RGBColor extends Color {\n  constructor(red, green, blue, alpha) {\n    super();\n    this.red = red;\n    this.green = green;\n    this.blue = blue;\n    this.alpha = alpha;\n  }\n  static parse(value) {\n    let colors = [];\n    if (/^#[\\da-f]+$/i.test(value) && [4, 5, 7, 9].includes(value.length)) {\n      const values = (value.length < 6 ? value.replace(/[^#]/gi, \"$&$&\") : value).slice(1).split(\"\");\n      while (values.length > 0) {\n        colors.push(parseInt(values.splice(0, 2).join(\"\"), 16));\n      }\n      colors[3] = colors[3] !== void 0 ? colors[3] / 255 : void 0;\n    }\n    const match = value.match(/^rgba?\\((.*)\\)$/);\n    if (match?.[1]) {\n      colors = match[1].split(\",\").map(value2 => Number(value2.trim())).map((num, i) => clampValue2(num, 0, i < 3 ? 255 : 1));\n    }\n    return colors.length < 3 ? void 0 : new _RGBColor(colors[0], colors[1], colors[2], colors[3] ?? 1);\n  }\n  toString(format) {\n    switch (format) {\n      case \"hex\":\n        return \"#\" + (this.red.toString(16).padStart(2, \"0\") + this.green.toString(16).padStart(2, \"0\") + this.blue.toString(16).padStart(2, \"0\")).toUpperCase();\n      case \"hexa\":\n        return \"#\" + (this.red.toString(16).padStart(2, \"0\") + this.green.toString(16).padStart(2, \"0\") + this.blue.toString(16).padStart(2, \"0\") + Math.round(this.alpha * 255).toString(16).padStart(2, \"0\")).toUpperCase();\n      case \"rgb\":\n        return `rgb(${this.red}, ${this.green}, ${this.blue})`;\n      case \"css\":\n      case \"rgba\":\n        return `rgba(${this.red}, ${this.green}, ${this.blue}, ${this.alpha})`;\n      case \"hsl\":\n        return this.toHSL().toString(\"hsl\");\n      case \"hsb\":\n        return this.toHSB().toString(\"hsb\");\n      default:\n        return this.toFormat(format).toString(format);\n    }\n  }\n  toFormat(format) {\n    switch (format) {\n      case \"rgba\":\n        return this;\n      case \"hsba\":\n        return this.toHSB();\n      case \"hsla\":\n        return this.toHSL();\n      default:\n        throw new Error(\"Unsupported color conversion: rgb -> \" + format);\n    }\n  }\n  toHexInt() {\n    return this.red << 16 | this.green << 8 | this.blue;\n  }\n  /**\n   * Converts an RGB color value to HSB.\n   * Conversion formula adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#From_RGB.\n   * @returns An HSBColor object.\n   */\n  toHSB() {\n    const red = this.red / 255;\n    const green = this.green / 255;\n    const blue = this.blue / 255;\n    const min = Math.min(red, green, blue);\n    const brightness = Math.max(red, green, blue);\n    const chroma = brightness - min;\n    const saturation = brightness === 0 ? 0 : chroma / brightness;\n    let hue = 0;\n    if (chroma !== 0) {\n      switch (brightness) {\n        case red:\n          hue = (green - blue) / chroma + (green < blue ? 6 : 0);\n          break;\n        case green:\n          hue = (blue - red) / chroma + 2;\n          break;\n        case blue:\n          hue = (red - green) / chroma + 4;\n          break;\n      }\n      hue /= 6;\n    }\n    return new HSBColor(toFixedNumber(hue * 360, 2), toFixedNumber(saturation * 100, 2), toFixedNumber(brightness * 100, 2), toFixedNumber(this.alpha, 2));\n  }\n  /**\n   * Converts an RGB color value to HSL.\n   * Conversion formula adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#From_RGB.\n   * @returns An HSLColor object.\n   */\n  toHSL() {\n    const red = this.red / 255;\n    const green = this.green / 255;\n    const blue = this.blue / 255;\n    const min = Math.min(red, green, blue);\n    const max = Math.max(red, green, blue);\n    const lightness = (max + min) / 2;\n    const chroma = max - min;\n    let hue = -1;\n    let saturation = -1;\n    if (chroma === 0) {\n      hue = saturation = 0;\n    } else {\n      saturation = chroma / (lightness < 0.5 ? max + min : 2 - max - min);\n      switch (max) {\n        case red:\n          hue = (green - blue) / chroma + (green < blue ? 6 : 0);\n          break;\n        case green:\n          hue = (blue - red) / chroma + 2;\n          break;\n        case blue:\n          hue = (red - green) / chroma + 4;\n          break;\n      }\n      hue /= 6;\n    }\n    return new HSLColor(toFixedNumber(hue * 360, 2), toFixedNumber(saturation * 100, 2), toFixedNumber(lightness * 100, 2), toFixedNumber(this.alpha, 2));\n  }\n  clone() {\n    return new _RGBColor(this.red, this.green, this.blue, this.alpha);\n  }\n  getChannelFormatOptions(channel) {\n    switch (channel) {\n      case \"red\":\n      case \"green\":\n      case \"blue\":\n        return {\n          style: \"decimal\"\n        };\n      case \"alpha\":\n        return {\n          style: \"percent\"\n        };\n      default:\n        throw new Error(\"Unknown color channel: \" + channel);\n    }\n  }\n  formatChannelValue(channel, locale) {\n    let options = this.getChannelFormatOptions(channel);\n    let value = this.getChannelValue(channel);\n    return new Intl.NumberFormat(locale, options).format(value);\n  }\n  getChannelRange(channel) {\n    switch (channel) {\n      case \"red\":\n      case \"green\":\n      case \"blue\":\n        return {\n          minValue: 0,\n          maxValue: 255,\n          step: 1,\n          pageSize: 17\n        };\n      case \"alpha\":\n        return {\n          minValue: 0,\n          maxValue: 1,\n          step: 0.01,\n          pageSize: 0.1\n        };\n      default:\n        throw new Error(\"Unknown color channel: \" + channel);\n    }\n  }\n  toJSON() {\n    return {\n      r: this.red,\n      g: this.green,\n      b: this.blue,\n      a: this.alpha\n    };\n  }\n  getFormat() {\n    return \"rgba\";\n  }\n  getChannels() {\n    return _RGBColor.colorChannels;\n  }\n};\n__publicField(_RGBColor, \"colorChannels\", [\"red\", \"green\", \"blue\"]);\nvar RGBColor = _RGBColor;\n\n// src/hsl-color.ts\nvar HSL_REGEX = /hsl\\(([-+]?\\d+(?:.\\d+)?\\s*,\\s*[-+]?\\d+(?:.\\d+)?%\\s*,\\s*[-+]?\\d+(?:.\\d+)?%)\\)|hsla\\(([-+]?\\d+(?:.\\d+)?\\s*,\\s*[-+]?\\d+(?:.\\d+)?%\\s*,\\s*[-+]?\\d+(?:.\\d+)?%\\s*,\\s*[-+]?\\d(.\\d+)?)\\)/;\nvar _HSLColor = class _HSLColor extends Color {\n  constructor(hue, saturation, lightness, alpha) {\n    super();\n    this.hue = hue;\n    this.saturation = saturation;\n    this.lightness = lightness;\n    this.alpha = alpha;\n  }\n  static parse(value) {\n    let m;\n    if (m = value.match(HSL_REGEX)) {\n      const [h, s, l, a] = (m[1] ?? m[2]).split(\",\").map(n => Number(n.trim().replace(\"%\", \"\")));\n      return new _HSLColor(mod(h, 360), clampValue3(s, 0, 100), clampValue3(l, 0, 100), clampValue3(a ?? 1, 0, 1));\n    }\n  }\n  toString(format) {\n    switch (format) {\n      case \"hex\":\n        return this.toRGB().toString(\"hex\");\n      case \"hexa\":\n        return this.toRGB().toString(\"hexa\");\n      case \"hsl\":\n        return `hsl(${this.hue}, ${toFixedNumber2(this.saturation, 2)}%, ${toFixedNumber2(this.lightness, 2)}%)`;\n      case \"css\":\n      case \"hsla\":\n        return `hsla(${this.hue}, ${toFixedNumber2(this.saturation, 2)}%, ${toFixedNumber2(this.lightness, 2)}%, ${this.alpha})`;\n      case \"hsb\":\n        return this.toHSB().toString(\"hsb\");\n      case \"rgb\":\n        return this.toRGB().toString(\"rgb\");\n      default:\n        return this.toFormat(format).toString(format);\n    }\n  }\n  toFormat(format) {\n    switch (format) {\n      case \"hsla\":\n        return this;\n      case \"hsba\":\n        return this.toHSB();\n      case \"rgba\":\n        return this.toRGB();\n      default:\n        throw new Error(\"Unsupported color conversion: hsl -> \" + format);\n    }\n  }\n  /**\n   * Converts a HSL color to HSB.\n   * Conversion formula adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#HSL_to_HSV.\n   * @returns An HSBColor object.\n   */\n  toHSB() {\n    let saturation = this.saturation / 100;\n    let lightness = this.lightness / 100;\n    let brightness = lightness + saturation * Math.min(lightness, 1 - lightness);\n    saturation = brightness === 0 ? 0 : 2 * (1 - lightness / brightness);\n    return new HSBColor(toFixedNumber2(this.hue, 2), toFixedNumber2(saturation * 100, 2), toFixedNumber2(brightness * 100, 2), toFixedNumber2(this.alpha, 2));\n  }\n  /**\n   * Converts a HSL color to RGB.\n   * Conversion formula adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#HSL_to_RGB_alternative.\n   * @returns An RGBColor object.\n   */\n  toRGB() {\n    let hue = this.hue;\n    let saturation = this.saturation / 100;\n    let lightness = this.lightness / 100;\n    let a = saturation * Math.min(lightness, 1 - lightness);\n    let fn = (n, k = (n + hue / 30) % 12) => lightness - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);\n    return new RGBColor(Math.round(fn(0) * 255), Math.round(fn(8) * 255), Math.round(fn(4) * 255), toFixedNumber2(this.alpha, 2));\n  }\n  clone() {\n    return new _HSLColor(this.hue, this.saturation, this.lightness, this.alpha);\n  }\n  getChannelFormatOptions(channel) {\n    switch (channel) {\n      case \"hue\":\n        return {\n          style: \"unit\",\n          unit: \"degree\",\n          unitDisplay: \"narrow\"\n        };\n      case \"saturation\":\n      case \"lightness\":\n      case \"alpha\":\n        return {\n          style: \"percent\"\n        };\n      default:\n        throw new Error(\"Unknown color channel: \" + channel);\n    }\n  }\n  formatChannelValue(channel, locale) {\n    let options = this.getChannelFormatOptions(channel);\n    let value = this.getChannelValue(channel);\n    if (channel === \"saturation\" || channel === \"lightness\") {\n      value /= 100;\n    }\n    return new Intl.NumberFormat(locale, options).format(value);\n  }\n  getChannelRange(channel) {\n    switch (channel) {\n      case \"hue\":\n        return {\n          minValue: 0,\n          maxValue: 360,\n          step: 1,\n          pageSize: 15\n        };\n      case \"saturation\":\n      case \"lightness\":\n        return {\n          minValue: 0,\n          maxValue: 100,\n          step: 1,\n          pageSize: 10\n        };\n      case \"alpha\":\n        return {\n          minValue: 0,\n          maxValue: 1,\n          step: 0.01,\n          pageSize: 0.1\n        };\n      default:\n        throw new Error(\"Unknown color channel: \" + channel);\n    }\n  }\n  toJSON() {\n    return {\n      h: this.hue,\n      s: this.saturation,\n      l: this.lightness,\n      a: this.alpha\n    };\n  }\n  getFormat() {\n    return \"hsla\";\n  }\n  getChannels() {\n    return _HSLColor.colorChannels;\n  }\n};\n__publicField(_HSLColor, \"colorChannels\", [\"hue\", \"saturation\", \"lightness\"]);\nvar HSLColor = _HSLColor;\n\n// src/hsb-color.ts\nvar HSB_REGEX = /hsb\\(([-+]?\\d+(?:.\\d+)?\\s*,\\s*[-+]?\\d+(?:.\\d+)?%\\s*,\\s*[-+]?\\d+(?:.\\d+)?%)\\)|hsba\\(([-+]?\\d+(?:.\\d+)?\\s*,\\s*[-+]?\\d+(?:.\\d+)?%\\s*,\\s*[-+]?\\d+(?:.\\d+)?%\\s*,\\s*[-+]?\\d(.\\d+)?)\\)/;\nvar _HSBColor = class _HSBColor extends Color {\n  constructor(hue, saturation, brightness, alpha) {\n    super();\n    this.hue = hue;\n    this.saturation = saturation;\n    this.brightness = brightness;\n    this.alpha = alpha;\n  }\n  static parse(value) {\n    let m;\n    if (m = value.match(HSB_REGEX)) {\n      const [h, s, b, a] = (m[1] ?? m[2]).split(\",\").map(n => Number(n.trim().replace(\"%\", \"\")));\n      return new _HSBColor(mod2(h, 360), clampValue4(s, 0, 100), clampValue4(b, 0, 100), clampValue4(a ?? 1, 0, 1));\n    }\n  }\n  toString(format) {\n    switch (format) {\n      case \"css\":\n        return this.toHSL().toString(\"css\");\n      case \"hex\":\n        return this.toRGB().toString(\"hex\");\n      case \"hexa\":\n        return this.toRGB().toString(\"hexa\");\n      case \"hsb\":\n        return `hsb(${this.hue}, ${toFixedNumber3(this.saturation, 2)}%, ${toFixedNumber3(this.brightness, 2)}%)`;\n      case \"hsba\":\n        return `hsba(${this.hue}, ${toFixedNumber3(this.saturation, 2)}%, ${toFixedNumber3(this.brightness, 2)}%, ${this.alpha})`;\n      case \"hsl\":\n        return this.toHSL().toString(\"hsl\");\n      case \"rgb\":\n        return this.toRGB().toString(\"rgb\");\n      default:\n        return this.toFormat(format).toString(format);\n    }\n  }\n  toFormat(format) {\n    switch (format) {\n      case \"hsba\":\n        return this;\n      case \"hsla\":\n        return this.toHSL();\n      case \"rgba\":\n        return this.toRGB();\n      default:\n        throw new Error(\"Unsupported color conversion: hsb -> \" + format);\n    }\n  }\n  /**\n   * Converts a HSB color to HSL.\n   * Conversion formula adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#HSV_to_HSL.\n   * @returns An HSLColor object.\n   */\n  toHSL() {\n    let saturation = this.saturation / 100;\n    let brightness = this.brightness / 100;\n    let lightness = brightness * (1 - saturation / 2);\n    saturation = lightness === 0 || lightness === 1 ? 0 : (brightness - lightness) / Math.min(lightness, 1 - lightness);\n    return new HSLColor(toFixedNumber3(this.hue, 2), toFixedNumber3(saturation * 100, 2), toFixedNumber3(lightness * 100, 2), toFixedNumber3(this.alpha, 2));\n  }\n  /**\n   * Converts a HSV color value to RGB.\n   * Conversion formula adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#HSV_to_RGB_alternative.\n   * @returns An RGBColor object.\n   */\n  toRGB() {\n    let hue = this.hue;\n    let saturation = this.saturation / 100;\n    let brightness = this.brightness / 100;\n    let fn = (n, k = (n + hue / 60) % 6) => brightness - saturation * brightness * Math.max(Math.min(k, 4 - k, 1), 0);\n    return new RGBColor(Math.round(fn(5) * 255), Math.round(fn(3) * 255), Math.round(fn(1) * 255), toFixedNumber3(this.alpha, 2));\n  }\n  clone() {\n    return new _HSBColor(this.hue, this.saturation, this.brightness, this.alpha);\n  }\n  getChannelFormatOptions(channel) {\n    switch (channel) {\n      case \"hue\":\n        return {\n          style: \"unit\",\n          unit: \"degree\",\n          unitDisplay: \"narrow\"\n        };\n      case \"saturation\":\n      case \"brightness\":\n      case \"alpha\":\n        return {\n          style: \"percent\"\n        };\n      default:\n        throw new Error(\"Unknown color channel: \" + channel);\n    }\n  }\n  formatChannelValue(channel, locale) {\n    let options = this.getChannelFormatOptions(channel);\n    let value = this.getChannelValue(channel);\n    if (channel === \"saturation\" || channel === \"brightness\") {\n      value /= 100;\n    }\n    return new Intl.NumberFormat(locale, options).format(value);\n  }\n  getChannelRange(channel) {\n    switch (channel) {\n      case \"hue\":\n        return {\n          minValue: 0,\n          maxValue: 360,\n          step: 1,\n          pageSize: 15\n        };\n      case \"saturation\":\n      case \"brightness\":\n        return {\n          minValue: 0,\n          maxValue: 100,\n          step: 1,\n          pageSize: 10\n        };\n      case \"alpha\":\n        return {\n          minValue: 0,\n          maxValue: 1,\n          step: 0.01,\n          pageSize: 0.1\n        };\n      default:\n        throw new Error(\"Unknown color channel: \" + channel);\n    }\n  }\n  toJSON() {\n    return {\n      h: this.hue,\n      s: this.saturation,\n      b: this.brightness,\n      a: this.alpha\n    };\n  }\n  getFormat() {\n    return \"hsba\";\n  }\n  getChannels() {\n    return _HSBColor.colorChannels;\n  }\n};\n__publicField(_HSBColor, \"colorChannels\", [\"hue\", \"saturation\", \"brightness\"]);\nvar HSBColor = _HSBColor;\n\n// src/native-color.ts\nvar nativeColors = \"aliceblue:f0f8ff,antiquewhite:faebd7,aqua:00ffff,aquamarine:7fffd4,azure:f0ffff,beige:f5f5dc,bisque:ffe4c4,black:000000,blanchedalmond:ffebcd,blue:0000ff,blueviolet:8a2be2,brown:a52a2a,burlywood:deb887,cadetblue:5f9ea0,chartreuse:7fff00,chocolate:d2691e,coral:ff7f50,cornflowerblue:6495ed,cornsilk:fff8dc,crimson:dc143c,cyan:00ffff,darkblue:00008b,darkcyan:008b8b,darkgoldenrod:b8860b,darkgray:a9a9a9,darkgreen:006400,darkkhaki:bdb76b,darkmagenta:8b008b,darkolivegreen:556b2f,darkorange:ff8c00,darkorchid:9932cc,darkred:8b0000,darksalmon:e9967a,darkseagreen:8fbc8f,darkslateblue:483d8b,darkslategray:2f4f4f,darkturquoise:00ced1,darkviolet:9400d3,deeppink:ff1493,deepskyblue:00bfff,dimgray:696969,dodgerblue:1e90ff,firebrick:b22222,floralwhite:fffaf0,forestgreen:228b22,fuchsia:ff00ff,gainsboro:dcdcdc,ghostwhite:f8f8ff,gold:ffd700,goldenrod:daa520,gray:808080,green:008000,greenyellow:adff2f,honeydew:f0fff0,hotpink:ff69b4,indianred:cd5c5c,indigo:4b0082,ivory:fffff0,khaki:f0e68c,lavender:e6e6fa,lavenderblush:fff0f5,lawngreen:7cfc00,lemonchiffon:fffacd,lightblue:add8e6,lightcoral:f08080,lightcyan:e0ffff,lightgoldenrodyellow:fafad2,lightgrey:d3d3d3,lightgreen:90ee90,lightpink:ffb6c1,lightsalmon:ffa07a,lightseagreen:20b2aa,lightskyblue:87cefa,lightslategray:778899,lightsteelblue:b0c4de,lightyellow:ffffe0,lime:00ff00,limegreen:32cd32,linen:faf0e6,magenta:ff00ff,maroon:800000,mediumaquamarine:66cdaa,mediumblue:0000cd,mediumorchid:ba55d3,mediumpurple:9370d8,mediumseagreen:3cb371,mediumslateblue:7b68ee,mediumspringgreen:00fa9a,mediumturquoise:48d1cc,mediumvioletred:c71585,midnightblue:191970,mintcream:f5fffa,mistyrose:ffe4e1,moccasin:ffe4b5,navajowhite:ffdead,navy:000080,oldlace:fdf5e6,olive:808000,olivedrab:6b8e23,orange:ffa500,orangered:ff4500,orchid:da70d6,palegoldenrod:eee8aa,palegreen:98fb98,paleturquoise:afeeee,palevioletred:d87093,papayawhip:ffefd5,peachpuff:ffdab9,peru:cd853f,pink:ffc0cb,plum:dda0dd,powderblue:b0e0e6,purple:800080,red:ff0000,rosybrown:bc8f8f,royalblue:4169e1,saddlebrown:8b4513,salmon:fa8072,sandybrown:f4a460,seagreen:2e8b57,seashell:fff5ee,sienna:a0522d,silver:c0c0c0,skyblue:87ceeb,slateblue:6a5acd,slategray:708090,snow:fffafa,springgreen:00ff7f,steelblue:4682b4,tan:d2b48c,teal:008080,thistle:d8bfd8,tomato:ff6347,turquoise:40e0d0,violet:ee82ee,wheat:f5deb3,white:ffffff,whitesmoke:f5f5f5,yellow:ffff00,yellowgreen:9acd32\";\nvar makeMap = str => {\n  const map = /* @__PURE__ */new Map();\n  const list = str.split(\",\");\n  for (let i = 0; i < list.length; i++) {\n    const [key, val] = list[i].split(\":\");\n    map.set(key, `#${val}`);\n  }\n  return map;\n};\nvar nativeColorMap = makeMap(nativeColors);\n\n// src/parse-color.ts\nvar parseColor = value => {\n  if (nativeColorMap.has(value)) {\n    return parseColor(nativeColorMap.get(value));\n  }\n  const result = RGBColor.parse(value) || HSBColor.parse(value) || HSLColor.parse(value);\n  if (!result) {\n    const error = new Error(\"Invalid color value: \" + value);\n    Error.captureStackTrace?.(error, parseColor);\n    throw error;\n  }\n  return result;\n};\nvar normalizeColor = v => {\n  return typeof v === \"string\" ? parseColor(v) : v;\n};\nexport { Color, getColorAreaGradient, normalizeColor, parseColor };","map":{"version":3,"names":["generateRGB_R","orientation","dir","zValue","maskImage","Number","result","areaStyles","backgroundImage","areaGradientStyles","WebkitMaskImage","generateRGB_G","generateRGB_B","generateHSL_H","background","join","generateHSL_S","alphaValue","generateHSL_L","generateHSB_H","generateHSB_S","generateHSB_B","getColorAreaGradient","color","options","xChannel","yChannel","dirProp","zChannel","getColorAxes","getChannelValue","minValue","zMin","maxValue","zMax","getChannelRange","isHSL","getFormat","clampValue","getPercentValue","getValuePercent","snapValueToStep","isEqualObject","a","b","Object","keys","length","key","Color","toHexInt","toFormat","channel","Error","getChannelValuePercent","valueToCheck","value","getChannelPercentValue","percentToCheck","step","percentValue","withChannelValue","clone","xyChannels","xCh","getChannels","find","c","yCh","zCh","incrementChannel","stepSize","decrementChannel","isEqual","isSame","toJSON","clampValue4","mod","mod2","toFixedNumber","toFixedNumber3","clampValue3","toFixedNumber2","clampValue2","_RGBColor","constructor","red","green","blue","alpha","parse","colors","test","includes","values","replace","slice","split","push","parseInt","splice","match","map","value2","trim","num","i","toString","format","padStart","toUpperCase","Math","round","toHSL","toHSB","min","brightness","max","chroma","saturation","hue","HSBColor","lightness","HSLColor","getChannelFormatOptions","style","formatChannelValue","locale","Intl","NumberFormat","pageSize","r","g","colorChannels","__publicField","RGBColor","HSL_REGEX","_HSLColor","m","h","s","l","n","toRGB","fn","k","unit","unitDisplay","HSB_REGEX","_HSBColor","nativeColors","makeMap","str","Map","list","val","set","nativeColorMap","parseColor","has","get","error","captureStackTrace","normalizeColor","v"],"sources":["C:\\Users\\lab_services_student\\Desktop\\PartThree\\frontend\\node_modules\\@zag-js\\color-utils\\src\\color-format-gradient.ts","C:\\Users\\lab_services_student\\Desktop\\PartThree\\frontend\\node_modules\\@zag-js\\color-utils\\src\\area-gradient.ts","C:\\Users\\lab_services_student\\Desktop\\PartThree\\frontend\\node_modules\\@zag-js\\color-utils\\src\\color.ts","C:\\Users\\lab_services_student\\Desktop\\PartThree\\frontend\\node_modules\\@zag-js\\color-utils\\src\\hsb-color.ts","C:\\Users\\lab_services_student\\Desktop\\PartThree\\frontend\\node_modules\\@zag-js\\color-utils\\src\\hsl-color.ts","C:\\Users\\lab_services_student\\Desktop\\PartThree\\frontend\\node_modules\\@zag-js\\color-utils\\src\\rgb-color.ts","C:\\Users\\lab_services_student\\Desktop\\PartThree\\frontend\\node_modules\\@zag-js\\color-utils\\src\\native-color.ts","C:\\Users\\lab_services_student\\Desktop\\PartThree\\frontend\\node_modules\\@zag-js\\color-utils\\src\\parse-color.ts"],"sourcesContent":["export const generateRGB_R = (orientation: [string, string], dir: boolean, zValue: number) => {\n  const maskImage = `linear-gradient(to ${orientation[Number(!dir)]}, transparent, #000)`\n  const result = {\n    areaStyles: {\n      backgroundImage: `linear-gradient(to ${orientation[Number(dir)]},rgb(${zValue},0,0),rgb(${zValue},255,0))`,\n    },\n    areaGradientStyles: {\n      backgroundImage: `linear-gradient(to ${orientation[Number(dir)]},rgb(${zValue},0,255),rgb(${zValue},255,255))`,\n      WebkitMaskImage: maskImage,\n      maskImage,\n    },\n  }\n  return result\n}\n\nexport const generateRGB_G = (orientation: [string, string], dir: boolean, zValue: number) => {\n  const maskImage = `linear-gradient(to ${orientation[Number(!dir)]}, transparent, #000)`\n  const result = {\n    areaStyles: {\n      backgroundImage: `linear-gradient(to ${orientation[Number(dir)]},rgb(0,${zValue},0),rgb(255,${zValue},0))`,\n    },\n    areaGradientStyles: {\n      backgroundImage: `linear-gradient(to ${orientation[Number(dir)]},rgb(0,${zValue},255),rgb(255,${zValue},255))`,\n      WebkitMaskImage: maskImage,\n      maskImage,\n    },\n  }\n  return result\n}\n\nexport const generateRGB_B = (orientation: [string, string], dir: boolean, zValue: number) => {\n  const maskImage = `linear-gradient(to ${orientation[Number(!dir)]}, transparent, #000)`\n  const result = {\n    areaStyles: {\n      backgroundImage: `linear-gradient(to ${orientation[Number(dir)]},rgb(0,0,${zValue}),rgb(255,0,${zValue}))`,\n    },\n    areaGradientStyles: {\n      backgroundImage: `linear-gradient(to ${orientation[Number(dir)]},rgb(0,255,${zValue}),rgb(255,255,${zValue}))`,\n      WebkitMaskImage: maskImage,\n      maskImage,\n    },\n  }\n  return result\n}\n\nexport const generateHSL_H = (orientation: [string, string], dir: boolean, zValue: number) => {\n  const result = {\n    areaStyles: {},\n    areaGradientStyles: {\n      background: [\n        `linear-gradient(to ${\n          orientation[Number(dir)]\n        }, hsla(0,0%,0%,1) 0%, hsla(0,0%,0%,0) 50%, hsla(0,0%,100%,0) 50%, hsla(0,0%,100%,1) 100%)`,\n        `linear-gradient(to ${orientation[Number(!dir)]},hsl(0,0%,50%),hsla(0,0%,50%,0))`,\n        `hsl(${zValue}, 100%, 50%)`,\n      ].join(\",\"),\n    },\n  }\n  return result\n}\n\nexport const generateHSL_S = (orientation: [string, string], dir: boolean, alphaValue: number) => {\n  const result = {\n    areaStyles: {},\n    areaGradientStyles: {\n      background: [\n        `linear-gradient(to ${\n          orientation[Number(!dir)]\n        }, hsla(0,0%,0%,${alphaValue}) 0%, hsla(0,0%,0%,0) 50%, hsla(0,0%,100%,0) 50%, hsla(0,0%,100%,${alphaValue}) 100%)`,\n        `linear-gradient(to ${\n          orientation[Number(dir)]\n        },hsla(0,100%,50%,${alphaValue}),hsla(60,100%,50%,${alphaValue}),hsla(120,100%,50%,${alphaValue}),hsla(180,100%,50%,${alphaValue}),hsla(240,100%,50%,${alphaValue}),hsla(300,100%,50%,${alphaValue}),hsla(359,100%,50%,${alphaValue}))`,\n        \"hsl(0, 0%, 50%)\",\n      ].join(\",\"),\n    },\n  }\n  return result\n}\n\nexport const generateHSL_L = (orientation: [string, string], dir: boolean, zValue: number) => {\n  const result = {\n    areaStyles: {},\n    areaGradientStyles: {\n      backgroundImage: [\n        `linear-gradient(to ${orientation[Number(!dir)]},hsl(0,0%,${zValue}%),hsla(0,0%,${zValue}%,0))`,\n        `linear-gradient(to ${\n          orientation[Number(dir)]\n        },hsl(0,100%,${zValue}%),hsl(60,100%,${zValue}%),hsl(120,100%,${zValue}%),hsl(180,100%,${zValue}%),hsl(240,100%,${zValue}%),hsl(300,100%,${zValue}%),hsl(360,100%,${zValue}%))`,\n      ].join(\",\"),\n    },\n  }\n  return result\n}\n\nexport const generateHSB_H = (orientation: [string, string], dir: boolean, zValue: number) => {\n  const result = {\n    areaStyles: {},\n    areaGradientStyles: {\n      background: [\n        `linear-gradient(to ${orientation[Number(dir)]},hsl(0,0%,0%),hsla(0,0%,0%,0))`,\n        `linear-gradient(to ${orientation[Number(!dir)]},hsl(0,0%,100%),hsla(0,0%,100%,0))`,\n        `hsl(${zValue}, 100%, 50%)`,\n      ].join(\",\"),\n    },\n  }\n  return result\n}\n\nexport const generateHSB_S = (orientation: [string, string], dir: boolean, alphaValue: number) => {\n  const result = {\n    areaStyles: {},\n    areaGradientStyles: {\n      background: [\n        `linear-gradient(to ${orientation[Number(!dir)]},hsla(0,0%,0%,${alphaValue}),hsla(0,0%,0%,0))`,\n        `linear-gradient(to ${\n          orientation[Number(dir)]\n        },hsla(0,100%,50%,${alphaValue}),hsla(60,100%,50%,${alphaValue}),hsla(120,100%,50%,${alphaValue}),hsla(180,100%,50%,${alphaValue}),hsla(240,100%,50%,${alphaValue}),hsla(300,100%,50%,${alphaValue}),hsla(359,100%,50%,${alphaValue}))`,\n        `linear-gradient(to ${orientation[Number(!dir)]},hsl(0,0%,0%),hsl(0,0%,100%))`,\n      ].join(\",\"),\n    },\n  }\n  return result\n}\n\nexport const generateHSB_B = (orientation: [string, string], dir: boolean, alphaValue: number) => {\n  const result = {\n    areaStyles: {},\n    areaGradientStyles: {\n      background: [\n        `linear-gradient(to ${orientation[Number(!dir)]},hsla(0,0%,100%,${alphaValue}),hsla(0,0%,100%,0))`,\n        `linear-gradient(to ${\n          orientation[Number(dir)]\n        },hsla(0,100%,50%,${alphaValue}),hsla(60,100%,50%,${alphaValue}),hsla(120,100%,50%,${alphaValue}),hsla(180,100%,50%,${alphaValue}),hsla(240,100%,50%,${alphaValue}),hsla(300,100%,50%,${alphaValue}),hsla(359,100%,50%,${alphaValue}))`,\n        \"#000\",\n      ].join(\",\"),\n    },\n  }\n  return result\n}\n","import type { Color } from \"./color\"\nimport {\n  generateRGB_R,\n  generateRGB_G,\n  generateRGB_B,\n  generateHSL_H,\n  generateHSB_H,\n  generateHSL_S,\n  generateHSB_S,\n  generateHSB_B,\n  generateHSL_L,\n} from \"./color-format-gradient\"\nimport type { ColorChannel } from \"./types\"\n\ninterface GradientOptions {\n  xChannel: ColorChannel\n  yChannel: ColorChannel\n  dir?: \"rtl\" | \"ltr\"\n}\n\ninterface GradientStyles {\n  areaStyles: Record<string, string>\n  areaGradientStyles: Record<string, string>\n}\n\nexport function getColorAreaGradient(color: Color, options: GradientOptions): GradientStyles {\n  const { xChannel, yChannel, dir: dirProp = \"ltr\" } = options\n\n  const { zChannel } = color.getColorAxes({ xChannel, yChannel })\n  const zValue = color.getChannelValue(zChannel)\n\n  const { minValue: zMin, maxValue: zMax } = color.getChannelRange(zChannel)\n  const orientation: [string, string] = [\"top\", dirProp === \"rtl\" ? \"left\" : \"right\"]\n\n  let dir = false\n\n  let background = { areaStyles: {}, areaGradientStyles: {} }\n\n  let alphaValue = (zValue - zMin) / (zMax - zMin)\n  let isHSL = color.getFormat() === \"hsla\"\n\n  switch (zChannel) {\n    case \"red\": {\n      dir = xChannel === \"green\"\n      background = generateRGB_R(orientation, dir, zValue)\n      break\n    }\n\n    case \"green\": {\n      dir = xChannel === \"red\"\n      background = generateRGB_G(orientation, dir, zValue)\n      break\n    }\n\n    case \"blue\": {\n      dir = xChannel === \"red\"\n      background = generateRGB_B(orientation, dir, zValue)\n      break\n    }\n\n    case \"hue\": {\n      dir = xChannel !== \"saturation\"\n      if (isHSL) {\n        background = generateHSL_H(orientation, dir, zValue)\n      } else {\n        background = generateHSB_H(orientation, dir, zValue)\n      }\n      break\n    }\n\n    case \"saturation\": {\n      dir = xChannel === \"hue\"\n      if (isHSL) {\n        background = generateHSL_S(orientation, dir, alphaValue)\n      } else {\n        background = generateHSB_S(orientation, dir, alphaValue)\n      }\n      break\n    }\n\n    case \"brightness\": {\n      dir = xChannel === \"hue\"\n      background = generateHSB_B(orientation, dir, alphaValue)\n      break\n    }\n\n    case \"lightness\": {\n      dir = xChannel === \"hue\"\n      background = generateHSL_L(orientation, dir, zValue)\n      break\n    }\n  }\n\n  return background\n}\n","import { clampValue, getPercentValue, getValuePercent, snapValueToStep } from \"@zag-js/numeric-range\"\nimport type {\n  Color2DAxes,\n  ColorAxes,\n  ColorChannel,\n  ColorChannelRange,\n  ColorFormat,\n  ColorStringFormat,\n  ColorType,\n} from \"./types\"\n\nconst isEqualObject = (a: Record<string, number>, b: Record<string, number>): boolean => {\n  if (Object.keys(a).length !== Object.keys(b).length) return false\n  for (let key in a) if (a[key] !== b[key]) return false\n  return true\n}\n\nexport abstract class Color implements ColorType {\n  abstract toFormat(format: ColorFormat): ColorType\n  abstract toJSON(): Record<string, number>\n  abstract toString(format: ColorStringFormat): string\n  abstract clone(): ColorType\n  abstract getChannelRange(channel: ColorChannel): ColorChannelRange\n  abstract getFormat(): ColorFormat\n  abstract getChannels(): [ColorChannel, ColorChannel, ColorChannel]\n  abstract formatChannelValue(channel: ColorChannel, locale: string): string\n\n  toHexInt(): number {\n    return this.toFormat(\"rgba\").toHexInt()\n  }\n\n  getChannelValue(channel: ColorChannel): number {\n    // @ts-ignore\n    if (channel in this) return this[channel]\n    throw new Error(\"Unsupported color channel: \" + channel)\n  }\n\n  getChannelValuePercent(channel: ColorChannel, valueToCheck?: number): number {\n    const value = valueToCheck ?? this.getChannelValue(channel)\n    const { minValue, maxValue } = this.getChannelRange(channel)\n    return getValuePercent(value, minValue, maxValue)\n  }\n\n  getChannelPercentValue(channel: ColorChannel, percentToCheck: number): number {\n    const { minValue, maxValue, step } = this.getChannelRange(channel)\n    const percentValue = getPercentValue(percentToCheck, minValue, maxValue, step)\n    return snapValueToStep(percentValue, minValue, maxValue, step)\n  }\n\n  withChannelValue(channel: ColorChannel, value: number): ColorType {\n    const { minValue, maxValue } = this.getChannelRange(channel)\n    if (channel in this) {\n      let clone = this.clone()\n      // @ts-ignore\n      clone[channel] = clampValue(value, minValue, maxValue)\n      return clone\n    }\n\n    throw new Error(\"Unsupported color channel: \" + channel)\n  }\n\n  getColorAxes(xyChannels: Color2DAxes): ColorAxes {\n    let { xChannel, yChannel } = xyChannels\n    let xCh = xChannel || this.getChannels().find((c) => c !== yChannel)\n    let yCh = yChannel || this.getChannels().find((c) => c !== xCh)\n    let zCh = this.getChannels().find((c) => c !== xCh && c !== yCh)\n    return { xChannel: xCh!, yChannel: yCh!, zChannel: zCh! }\n  }\n\n  incrementChannel(channel: ColorChannel, stepSize: number): ColorType {\n    const { minValue, maxValue, step } = this.getChannelRange(channel)\n    const value = snapValueToStep(\n      clampValue(this.getChannelValue(channel) + stepSize, minValue, maxValue),\n      minValue,\n      maxValue,\n      step,\n    )\n    return this.withChannelValue(channel, value)\n  }\n\n  decrementChannel(channel: ColorChannel, stepSize: number): ColorType {\n    return this.incrementChannel(channel, -stepSize)\n  }\n\n  isEqual(color: ColorType): boolean {\n    const isSame = isEqualObject(this.toJSON(), color.toJSON())\n    return isSame && this.getChannelValue(\"alpha\") === color.getChannelValue(\"alpha\")\n  }\n}\n","import { clampValue, mod, toFixedNumber } from \"@zag-js/numeric-range\"\nimport { Color } from \"./color\"\nimport { HSLColor } from \"./hsl-color\"\nimport { RGBColor } from \"./rgb-color\"\nimport type { ColorChannel, ColorChannelRange, ColorFormat, ColorStringFormat, ColorType } from \"./types\"\n\nconst HSB_REGEX =\n  /hsb\\(([-+]?\\d+(?:.\\d+)?\\s*,\\s*[-+]?\\d+(?:.\\d+)?%\\s*,\\s*[-+]?\\d+(?:.\\d+)?%)\\)|hsba\\(([-+]?\\d+(?:.\\d+)?\\s*,\\s*[-+]?\\d+(?:.\\d+)?%\\s*,\\s*[-+]?\\d+(?:.\\d+)?%\\s*,\\s*[-+]?\\d(.\\d+)?)\\)/\n\nexport class HSBColor extends Color {\n  constructor(\n    private hue: number,\n    private saturation: number,\n    private brightness: number,\n    private alpha: number,\n  ) {\n    super()\n  }\n\n  static parse(value: string): HSBColor | void {\n    let m: RegExpMatchArray | null\n    if ((m = value.match(HSB_REGEX))) {\n      const [h, s, b, a] = (m[1] ?? m[2]).split(\",\").map((n) => Number(n.trim().replace(\"%\", \"\")))\n      return new HSBColor(mod(h, 360), clampValue(s, 0, 100), clampValue(b, 0, 100), clampValue(a ?? 1, 0, 1))\n    }\n  }\n\n  toString(format: ColorStringFormat) {\n    switch (format) {\n      case \"css\":\n        return this.toHSL().toString(\"css\")\n      case \"hex\":\n        return this.toRGB().toString(\"hex\")\n      case \"hexa\":\n        return this.toRGB().toString(\"hexa\")\n      case \"hsb\":\n        return `hsb(${this.hue}, ${toFixedNumber(this.saturation, 2)}%, ${toFixedNumber(this.brightness, 2)}%)`\n      case \"hsba\":\n        return `hsba(${this.hue}, ${toFixedNumber(this.saturation, 2)}%, ${toFixedNumber(this.brightness, 2)}%, ${\n          this.alpha\n        })`\n      case \"hsl\":\n        return this.toHSL().toString(\"hsl\")\n      case \"rgb\":\n        return this.toRGB().toString(\"rgb\")\n      default:\n        return this.toFormat(format).toString(format)\n    }\n  }\n\n  toFormat(format: ColorFormat): ColorType {\n    switch (format) {\n      case \"hsba\":\n        return this\n      case \"hsla\":\n        return this.toHSL()\n      case \"rgba\":\n        return this.toRGB()\n      default:\n        throw new Error(\"Unsupported color conversion: hsb -> \" + format)\n    }\n  }\n\n  /**\n   * Converts a HSB color to HSL.\n   * Conversion formula adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#HSV_to_HSL.\n   * @returns An HSLColor object.\n   */\n  private toHSL(): ColorType {\n    let saturation = this.saturation / 100\n    let brightness = this.brightness / 100\n    let lightness = brightness * (1 - saturation / 2)\n    saturation = lightness === 0 || lightness === 1 ? 0 : (brightness - lightness) / Math.min(lightness, 1 - lightness)\n\n    return new HSLColor(\n      toFixedNumber(this.hue, 2),\n      toFixedNumber(saturation * 100, 2),\n      toFixedNumber(lightness * 100, 2),\n      toFixedNumber(this.alpha, 2),\n    )\n  }\n\n  /**\n   * Converts a HSV color value to RGB.\n   * Conversion formula adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#HSV_to_RGB_alternative.\n   * @returns An RGBColor object.\n   */\n  private toRGB(): ColorType {\n    let hue = this.hue\n    let saturation = this.saturation / 100\n    let brightness = this.brightness / 100\n\n    let fn = (n: number, k = (n + hue / 60) % 6) =>\n      brightness - saturation * brightness * Math.max(Math.min(k, 4 - k, 1), 0)\n\n    return new RGBColor(\n      Math.round(fn(5) * 255),\n      Math.round(fn(3) * 255),\n      Math.round(fn(1) * 255),\n      toFixedNumber(this.alpha, 2),\n    )\n  }\n\n  clone(): ColorType {\n    return new HSBColor(this.hue, this.saturation, this.brightness, this.alpha)\n  }\n\n  getChannelFormatOptions(channel: ColorChannel): Intl.NumberFormatOptions {\n    switch (channel) {\n      case \"hue\":\n        return { style: \"unit\", unit: \"degree\", unitDisplay: \"narrow\" }\n      case \"saturation\":\n      case \"brightness\":\n      case \"alpha\":\n        return { style: \"percent\" }\n      default:\n        throw new Error(\"Unknown color channel: \" + channel)\n    }\n  }\n\n  formatChannelValue(channel: ColorChannel, locale: string) {\n    let options = this.getChannelFormatOptions(channel)\n    let value = this.getChannelValue(channel)\n    if (channel === \"saturation\" || channel === \"brightness\") {\n      value /= 100\n    }\n    return new Intl.NumberFormat(locale, options).format(value)\n  }\n\n  getChannelRange(channel: ColorChannel): ColorChannelRange {\n    switch (channel) {\n      case \"hue\":\n        return { minValue: 0, maxValue: 360, step: 1, pageSize: 15 }\n      case \"saturation\":\n      case \"brightness\":\n        return { minValue: 0, maxValue: 100, step: 1, pageSize: 10 }\n      case \"alpha\":\n        return { minValue: 0, maxValue: 1, step: 0.01, pageSize: 0.1 }\n      default:\n        throw new Error(\"Unknown color channel: \" + channel)\n    }\n  }\n\n  toJSON(): Record<\"h\" | \"s\" | \"b\" | \"a\", number> {\n    return { h: this.hue, s: this.saturation, b: this.brightness, a: this.alpha }\n  }\n\n  getFormat(): ColorFormat {\n    return \"hsba\"\n  }\n\n  private static colorChannels: [ColorChannel, ColorChannel, ColorChannel] = [\"hue\", \"saturation\", \"brightness\"]\n\n  getChannels(): [ColorChannel, ColorChannel, ColorChannel] {\n    return HSBColor.colorChannels\n  }\n}\n","import { clampValue, mod, toFixedNumber } from \"@zag-js/numeric-range\"\nimport { Color } from \"./color\"\nimport { HSBColor } from \"./hsb-color\"\nimport { RGBColor } from \"./rgb-color\"\nimport type { ColorChannel, ColorChannelRange, ColorFormat, ColorStringFormat, ColorType } from \"./types\"\n\nexport const HSL_REGEX =\n  /hsl\\(([-+]?\\d+(?:.\\d+)?\\s*,\\s*[-+]?\\d+(?:.\\d+)?%\\s*,\\s*[-+]?\\d+(?:.\\d+)?%)\\)|hsla\\(([-+]?\\d+(?:.\\d+)?\\s*,\\s*[-+]?\\d+(?:.\\d+)?%\\s*,\\s*[-+]?\\d+(?:.\\d+)?%\\s*,\\s*[-+]?\\d(.\\d+)?)\\)/\n\nexport class HSLColor extends Color {\n  constructor(\n    private hue: number,\n    private saturation: number,\n    private lightness: number,\n    private alpha: number,\n  ) {\n    super()\n  }\n\n  static parse(value: string): HSLColor | void {\n    let m: RegExpMatchArray | null\n    if ((m = value.match(HSL_REGEX))) {\n      const [h, s, l, a] = (m[1] ?? m[2]).split(\",\").map((n) => Number(n.trim().replace(\"%\", \"\")))\n      return new HSLColor(mod(h, 360), clampValue(s, 0, 100), clampValue(l, 0, 100), clampValue(a ?? 1, 0, 1))\n    }\n  }\n\n  toString(format: ColorStringFormat) {\n    switch (format) {\n      case \"hex\":\n        return this.toRGB().toString(\"hex\")\n      case \"hexa\":\n        return this.toRGB().toString(\"hexa\")\n      case \"hsl\":\n        return `hsl(${this.hue}, ${toFixedNumber(this.saturation, 2)}%, ${toFixedNumber(this.lightness, 2)}%)`\n      case \"css\":\n      case \"hsla\":\n        return `hsla(${this.hue}, ${toFixedNumber(this.saturation, 2)}%, ${toFixedNumber(this.lightness, 2)}%, ${\n          this.alpha\n        })`\n      case \"hsb\":\n        return this.toHSB().toString(\"hsb\")\n      case \"rgb\":\n        return this.toRGB().toString(\"rgb\")\n      default:\n        return this.toFormat(format).toString(format)\n    }\n  }\n\n  toFormat(format: ColorFormat): ColorType {\n    switch (format) {\n      case \"hsla\":\n        return this\n      case \"hsba\":\n        return this.toHSB()\n      case \"rgba\":\n        return this.toRGB()\n      default:\n        throw new Error(\"Unsupported color conversion: hsl -> \" + format)\n    }\n  }\n\n  /**\n   * Converts a HSL color to HSB.\n   * Conversion formula adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#HSL_to_HSV.\n   * @returns An HSBColor object.\n   */\n  private toHSB(): ColorType {\n    let saturation = this.saturation / 100\n    let lightness = this.lightness / 100\n    let brightness = lightness + saturation * Math.min(lightness, 1 - lightness)\n    saturation = brightness === 0 ? 0 : 2 * (1 - lightness / brightness)\n    return new HSBColor(\n      toFixedNumber(this.hue, 2),\n      toFixedNumber(saturation * 100, 2),\n      toFixedNumber(brightness * 100, 2),\n      toFixedNumber(this.alpha, 2),\n    )\n  }\n\n  /**\n   * Converts a HSL color to RGB.\n   * Conversion formula adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#HSL_to_RGB_alternative.\n   * @returns An RGBColor object.\n   */\n  private toRGB(): ColorType {\n    let hue = this.hue\n    let saturation = this.saturation / 100\n    let lightness = this.lightness / 100\n    let a = saturation * Math.min(lightness, 1 - lightness)\n    let fn = (n: number, k = (n + hue / 30) % 12) => lightness - a * Math.max(Math.min(k - 3, 9 - k, 1), -1)\n    return new RGBColor(\n      Math.round(fn(0) * 255),\n      Math.round(fn(8) * 255),\n      Math.round(fn(4) * 255),\n      toFixedNumber(this.alpha, 2),\n    )\n  }\n\n  clone(): ColorType {\n    return new HSLColor(this.hue, this.saturation, this.lightness, this.alpha)\n  }\n\n  getChannelFormatOptions(channel: ColorChannel): Intl.NumberFormatOptions {\n    switch (channel) {\n      case \"hue\":\n        return { style: \"unit\", unit: \"degree\", unitDisplay: \"narrow\" }\n      case \"saturation\":\n      case \"lightness\":\n      case \"alpha\":\n        return { style: \"percent\" }\n      default:\n        throw new Error(\"Unknown color channel: \" + channel)\n    }\n  }\n\n  formatChannelValue(channel: ColorChannel, locale: string) {\n    let options = this.getChannelFormatOptions(channel)\n    let value = this.getChannelValue(channel)\n    if (channel === \"saturation\" || channel === \"lightness\") {\n      value /= 100\n    }\n    return new Intl.NumberFormat(locale, options).format(value)\n  }\n\n  getChannelRange(channel: ColorChannel): ColorChannelRange {\n    switch (channel) {\n      case \"hue\":\n        return { minValue: 0, maxValue: 360, step: 1, pageSize: 15 }\n      case \"saturation\":\n      case \"lightness\":\n        return { minValue: 0, maxValue: 100, step: 1, pageSize: 10 }\n      case \"alpha\":\n        return { minValue: 0, maxValue: 1, step: 0.01, pageSize: 0.1 }\n      default:\n        throw new Error(\"Unknown color channel: \" + channel)\n    }\n  }\n\n  toJSON(): Record<\"h\" | \"s\" | \"l\" | \"a\", number> {\n    return { h: this.hue, s: this.saturation, l: this.lightness, a: this.alpha }\n  }\n\n  getFormat(): ColorFormat {\n    return \"hsla\"\n  }\n\n  private static colorChannels: [ColorChannel, ColorChannel, ColorChannel] = [\"hue\", \"saturation\", \"lightness\"]\n\n  getChannels(): [ColorChannel, ColorChannel, ColorChannel] {\n    return HSLColor.colorChannels\n  }\n}\n","import { clampValue, toFixedNumber } from \"@zag-js/numeric-range\"\nimport { Color } from \"./color\"\nimport { HSBColor } from \"./hsb-color\"\nimport { HSLColor } from \"./hsl-color\"\nimport type { ColorChannel, ColorChannelRange, ColorFormat, ColorStringFormat, ColorType } from \"./types\"\n\nexport class RGBColor extends Color {\n  constructor(\n    private red: number,\n    private green: number,\n    private blue: number,\n    private alpha: number,\n  ) {\n    super()\n  }\n\n  static parse(value: string) {\n    let colors: (number | undefined)[] = []\n\n    // matching #rgb, #rgba, #rrggbb, #rrggbbaa\n    if (/^#[\\da-f]+$/i.test(value) && [4, 5, 7, 9].includes(value.length)) {\n      const values = (value.length < 6 ? value.replace(/[^#]/gi, \"$&$&\") : value).slice(1).split(\"\")\n      while (values.length > 0) {\n        colors.push(parseInt(values.splice(0, 2).join(\"\"), 16))\n      }\n      colors[3] = colors[3] !== undefined ? colors[3] / 255 : undefined\n    }\n\n    // matching rgb(rrr, ggg, bbb), rgba(rrr, ggg, bbb, 0.a)\n    const match = value.match(/^rgba?\\((.*)\\)$/)\n\n    if (match?.[1]) {\n      colors = match[1]\n        .split(\",\")\n        .map((value) => Number(value.trim()))\n        .map((num, i) => clampValue(num, 0, i < 3 ? 255 : 1))\n    }\n\n    //@ts-expect-error\n    return colors.length < 3 ? undefined : new RGBColor(colors[0], colors[1], colors[2], colors[3] ?? 1)\n  }\n\n  toString(format: ColorStringFormat) {\n    switch (format) {\n      case \"hex\":\n        return (\n          \"#\" +\n          (\n            this.red.toString(16).padStart(2, \"0\") +\n            this.green.toString(16).padStart(2, \"0\") +\n            this.blue.toString(16).padStart(2, \"0\")\n          ).toUpperCase()\n        )\n      case \"hexa\":\n        return (\n          \"#\" +\n          (\n            this.red.toString(16).padStart(2, \"0\") +\n            this.green.toString(16).padStart(2, \"0\") +\n            this.blue.toString(16).padStart(2, \"0\") +\n            Math.round(this.alpha * 255)\n              .toString(16)\n              .padStart(2, \"0\")\n          ).toUpperCase()\n        )\n      case \"rgb\":\n        return `rgb(${this.red}, ${this.green}, ${this.blue})`\n      case \"css\":\n      case \"rgba\":\n        return `rgba(${this.red}, ${this.green}, ${this.blue}, ${this.alpha})`\n      case \"hsl\":\n        return this.toHSL().toString(\"hsl\")\n      case \"hsb\":\n        return this.toHSB().toString(\"hsb\")\n      default:\n        return this.toFormat(format).toString(format)\n    }\n  }\n\n  toFormat(format: ColorFormat): ColorType {\n    switch (format) {\n      case \"rgba\":\n        return this\n      case \"hsba\":\n        return this.toHSB()\n      case \"hsla\":\n        return this.toHSL()\n      default:\n        throw new Error(\"Unsupported color conversion: rgb -> \" + format)\n    }\n  }\n\n  toHexInt(): number {\n    return (this.red << 16) | (this.green << 8) | this.blue\n  }\n\n  /**\n   * Converts an RGB color value to HSB.\n   * Conversion formula adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#From_RGB.\n   * @returns An HSBColor object.\n   */\n  private toHSB(): ColorType {\n    const red = this.red / 255\n    const green = this.green / 255\n    const blue = this.blue / 255\n    const min = Math.min(red, green, blue)\n    const brightness = Math.max(red, green, blue)\n    const chroma = brightness - min\n    const saturation = brightness === 0 ? 0 : chroma / brightness\n    let hue = 0 // achromatic\n\n    if (chroma !== 0) {\n      switch (brightness) {\n        case red:\n          hue = (green - blue) / chroma + (green < blue ? 6 : 0)\n          break\n        case green:\n          hue = (blue - red) / chroma + 2\n          break\n        case blue:\n          hue = (red - green) / chroma + 4\n          break\n      }\n\n      hue /= 6\n    }\n\n    return new HSBColor(\n      toFixedNumber(hue * 360, 2),\n      toFixedNumber(saturation * 100, 2),\n      toFixedNumber(brightness * 100, 2),\n      toFixedNumber(this.alpha, 2),\n    )\n  }\n\n  /**\n   * Converts an RGB color value to HSL.\n   * Conversion formula adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#From_RGB.\n   * @returns An HSLColor object.\n   */\n  private toHSL(): ColorType {\n    const red = this.red / 255\n    const green = this.green / 255\n    const blue = this.blue / 255\n    const min = Math.min(red, green, blue)\n    const max = Math.max(red, green, blue)\n    const lightness = (max + min) / 2\n    const chroma = max - min\n\n    let hue = -1\n    let saturation = -1\n\n    if (chroma === 0) {\n      hue = saturation = 0 // achromatic\n    } else {\n      saturation = chroma / (lightness < 0.5 ? max + min : 2 - max - min)\n\n      switch (max) {\n        case red:\n          hue = (green - blue) / chroma + (green < blue ? 6 : 0)\n          break\n        case green:\n          hue = (blue - red) / chroma + 2\n          break\n        case blue:\n          hue = (red - green) / chroma + 4\n          break\n      }\n\n      hue /= 6\n    }\n\n    return new HSLColor(\n      toFixedNumber(hue * 360, 2),\n      toFixedNumber(saturation * 100, 2),\n      toFixedNumber(lightness * 100, 2),\n      toFixedNumber(this.alpha, 2),\n    )\n  }\n\n  clone(): ColorType {\n    return new RGBColor(this.red, this.green, this.blue, this.alpha)\n  }\n\n  getChannelFormatOptions(channel: ColorChannel): Intl.NumberFormatOptions {\n    switch (channel) {\n      case \"red\":\n      case \"green\":\n      case \"blue\":\n        return { style: \"decimal\" }\n      case \"alpha\":\n        return { style: \"percent\" }\n      default:\n        throw new Error(\"Unknown color channel: \" + channel)\n    }\n  }\n\n  formatChannelValue(channel: ColorChannel, locale: string) {\n    let options = this.getChannelFormatOptions(channel)\n    let value = this.getChannelValue(channel)\n    return new Intl.NumberFormat(locale, options).format(value)\n  }\n\n  getChannelRange(channel: ColorChannel): ColorChannelRange {\n    switch (channel) {\n      case \"red\":\n      case \"green\":\n      case \"blue\":\n        return { minValue: 0x0, maxValue: 0xff, step: 0x1, pageSize: 0x11 }\n      case \"alpha\":\n        return { minValue: 0, maxValue: 1, step: 0.01, pageSize: 0.1 }\n      default:\n        throw new Error(\"Unknown color channel: \" + channel)\n    }\n  }\n\n  toJSON(): Record<\"r\" | \"g\" | \"b\" | \"a\", number> {\n    return { r: this.red, g: this.green, b: this.blue, a: this.alpha }\n  }\n\n  getFormat(): ColorFormat {\n    return \"rgba\"\n  }\n\n  private static colorChannels: [ColorChannel, ColorChannel, ColorChannel] = [\"red\", \"green\", \"blue\"]\n\n  getChannels(): [ColorChannel, ColorChannel, ColorChannel] {\n    return RGBColor.colorChannels\n  }\n}\n","const nativeColors /* @__PURE__ */ =\n  \"aliceblue:f0f8ff,antiquewhite:faebd7,aqua:00ffff,aquamarine:7fffd4,azure:f0ffff,beige:f5f5dc,bisque:ffe4c4,black:000000,blanchedalmond:ffebcd,blue:0000ff,blueviolet:8a2be2,brown:a52a2a,burlywood:deb887,cadetblue:5f9ea0,chartreuse:7fff00,chocolate:d2691e,coral:ff7f50,cornflowerblue:6495ed,cornsilk:fff8dc,crimson:dc143c,cyan:00ffff,darkblue:00008b,darkcyan:008b8b,darkgoldenrod:b8860b,darkgray:a9a9a9,darkgreen:006400,darkkhaki:bdb76b,darkmagenta:8b008b,darkolivegreen:556b2f,darkorange:ff8c00,darkorchid:9932cc,darkred:8b0000,darksalmon:e9967a,darkseagreen:8fbc8f,darkslateblue:483d8b,darkslategray:2f4f4f,darkturquoise:00ced1,darkviolet:9400d3,deeppink:ff1493,deepskyblue:00bfff,dimgray:696969,dodgerblue:1e90ff,firebrick:b22222,floralwhite:fffaf0,forestgreen:228b22,fuchsia:ff00ff,gainsboro:dcdcdc,ghostwhite:f8f8ff,gold:ffd700,goldenrod:daa520,gray:808080,green:008000,greenyellow:adff2f,honeydew:f0fff0,hotpink:ff69b4,indianred:cd5c5c,indigo:4b0082,ivory:fffff0,khaki:f0e68c,lavender:e6e6fa,lavenderblush:fff0f5,lawngreen:7cfc00,lemonchiffon:fffacd,lightblue:add8e6,lightcoral:f08080,lightcyan:e0ffff,lightgoldenrodyellow:fafad2,lightgrey:d3d3d3,lightgreen:90ee90,lightpink:ffb6c1,lightsalmon:ffa07a,lightseagreen:20b2aa,lightskyblue:87cefa,lightslategray:778899,lightsteelblue:b0c4de,lightyellow:ffffe0,lime:00ff00,limegreen:32cd32,linen:faf0e6,magenta:ff00ff,maroon:800000,mediumaquamarine:66cdaa,mediumblue:0000cd,mediumorchid:ba55d3,mediumpurple:9370d8,mediumseagreen:3cb371,mediumslateblue:7b68ee,mediumspringgreen:00fa9a,mediumturquoise:48d1cc,mediumvioletred:c71585,midnightblue:191970,mintcream:f5fffa,mistyrose:ffe4e1,moccasin:ffe4b5,navajowhite:ffdead,navy:000080,oldlace:fdf5e6,olive:808000,olivedrab:6b8e23,orange:ffa500,orangered:ff4500,orchid:da70d6,palegoldenrod:eee8aa,palegreen:98fb98,paleturquoise:afeeee,palevioletred:d87093,papayawhip:ffefd5,peachpuff:ffdab9,peru:cd853f,pink:ffc0cb,plum:dda0dd,powderblue:b0e0e6,purple:800080,red:ff0000,rosybrown:bc8f8f,royalblue:4169e1,saddlebrown:8b4513,salmon:fa8072,sandybrown:f4a460,seagreen:2e8b57,seashell:fff5ee,sienna:a0522d,silver:c0c0c0,skyblue:87ceeb,slateblue:6a5acd,slategray:708090,snow:fffafa,springgreen:00ff7f,steelblue:4682b4,tan:d2b48c,teal:008080,thistle:d8bfd8,tomato:ff6347,turquoise:40e0d0,violet:ee82ee,wheat:f5deb3,white:ffffff,whitesmoke:f5f5f5,yellow:ffff00,yellowgreen:9acd32\"\n\nconst makeMap = (str: string) => {\n  const map = new Map<string, string>()\n  const list = str.split(\",\")\n  for (let i = 0; i < list.length; i++) {\n    const [key, val] = list[i].split(\":\")\n    map.set(key, `#${val}`)\n  }\n  return map\n}\n\nexport const nativeColorMap /* @__PURE__ */ = makeMap(nativeColors)\n","import { HSBColor } from \"./hsb-color\"\nimport { HSLColor } from \"./hsl-color\"\nimport { nativeColorMap } from \"./native-color\"\nimport { RGBColor } from \"./rgb-color\"\nimport type { ColorType } from \"./types\"\n\nexport const parseColor = (value: string): ColorType => {\n  if (nativeColorMap.has(value)) {\n    return parseColor(nativeColorMap.get(value)!)\n  }\n\n  const result = RGBColor.parse(value) || HSBColor.parse(value) || HSLColor.parse(value)\n\n  if (!result) {\n    const error = new Error(\"Invalid color value: \" + value)\n    Error.captureStackTrace?.(error, parseColor)\n    throw error\n  }\n\n  return result\n}\n\nexport const normalizeColor = (v: string | ColorType) => {\n  return typeof v === \"string\" ? parseColor(v) : v\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
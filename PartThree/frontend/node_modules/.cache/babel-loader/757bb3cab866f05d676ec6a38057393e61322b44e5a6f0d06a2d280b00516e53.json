{"ast":null,"code":"// src/global.ts\nfunction getGlobal() {\n  if (typeof globalThis !== \"undefined\") return globalThis;\n  if (typeof self !== \"undefined\") return self;\n  if (typeof window !== \"undefined\") return window;\n  if (typeof global !== \"undefined\") return global;\n}\nfunction makeGlobal(key, value) {\n  const g = getGlobal();\n  if (!g) return value();\n  g[key] || (g[key] = value());\n  return g[key];\n}\n\n// src/proxy.ts\nimport { getUntracked, markToTrack } from \"proxy-compare\";\nvar isDev = () => process.env.NODE_ENV !== \"production\";\nvar isObject = x => typeof x === \"object\" && x !== null;\nvar proxyStateMap = makeGlobal(\"__zag__proxyStateMap\", () => /* @__PURE__ */new WeakMap());\nvar refSet = makeGlobal(\"__zag__refSet\", () => /* @__PURE__ */new WeakSet());\nvar buildProxyFunction = (objectIs = Object.is, newProxy = (target, handler) => new Proxy(target, handler), canProxy = x => isObject(x) && !refSet.has(x) && (Array.isArray(x) || !(Symbol.iterator in x)) && !(x instanceof WeakMap) && !(x instanceof WeakSet) && !(x instanceof Error) && !(x instanceof Number) && !(x instanceof Date) && !(x instanceof String) && !(x instanceof RegExp) && !(x instanceof ArrayBuffer), defaultHandlePromise = promise => {\n  switch (promise.status) {\n    case \"fulfilled\":\n      return promise.value;\n    case \"rejected\":\n      throw promise.reason;\n    default:\n      throw promise;\n  }\n}, snapCache = /* @__PURE__ */new WeakMap(), createSnapshot = (target, version, handlePromise = defaultHandlePromise) => {\n  const cache = snapCache.get(target);\n  if (cache?.[0] === version) {\n    return cache[1];\n  }\n  const snap = Array.isArray(target) ? [] : Object.create(Object.getPrototypeOf(target));\n  markToTrack(snap, true);\n  snapCache.set(target, [version, snap]);\n  Reflect.ownKeys(target).forEach(key => {\n    const value = Reflect.get(target, key);\n    if (refSet.has(value)) {\n      markToTrack(value, false);\n      snap[key] = value;\n    } else if (value instanceof Promise) {\n      Object.defineProperty(snap, key, {\n        get() {\n          return handlePromise(value);\n        }\n      });\n    } else if (proxyStateMap.has(value)) {\n      snap[key] = snapshot(value, handlePromise);\n    } else {\n      snap[key] = value;\n    }\n  });\n  return Object.freeze(snap);\n}, proxyCache = /* @__PURE__ */new WeakMap(), versionHolder = [1, 1], proxyFunction2 = initialObject => {\n  if (!isObject(initialObject)) {\n    throw new Error(\"object required\");\n  }\n  const found = proxyCache.get(initialObject);\n  if (found) {\n    return found;\n  }\n  let version = versionHolder[0];\n  const listeners = /* @__PURE__ */new Set();\n  const notifyUpdate = (op, nextVersion = ++versionHolder[0]) => {\n    if (version !== nextVersion) {\n      version = nextVersion;\n      listeners.forEach(listener => listener(op, nextVersion));\n    }\n  };\n  let checkVersion = versionHolder[1];\n  const ensureVersion = (nextCheckVersion = ++versionHolder[1]) => {\n    if (checkVersion !== nextCheckVersion && !listeners.size) {\n      checkVersion = nextCheckVersion;\n      propProxyStates.forEach(([propProxyState]) => {\n        const propVersion = propProxyState[1](nextCheckVersion);\n        if (propVersion > version) {\n          version = propVersion;\n        }\n      });\n    }\n    return version;\n  };\n  const createPropListener = prop => (op, nextVersion) => {\n    const newOp = [...op];\n    newOp[1] = [prop, ...newOp[1]];\n    notifyUpdate(newOp, nextVersion);\n  };\n  const propProxyStates = /* @__PURE__ */new Map();\n  const addPropListener = (prop, propProxyState) => {\n    if (isDev() && propProxyStates.has(prop)) {\n      throw new Error(\"prop listener already exists\");\n    }\n    if (listeners.size) {\n      const remove = propProxyState[3](createPropListener(prop));\n      propProxyStates.set(prop, [propProxyState, remove]);\n    } else {\n      propProxyStates.set(prop, [propProxyState]);\n    }\n  };\n  const removePropListener = prop => {\n    const entry = propProxyStates.get(prop);\n    if (entry) {\n      propProxyStates.delete(prop);\n      entry[1]?.();\n    }\n  };\n  const addListener = listener => {\n    listeners.add(listener);\n    if (listeners.size === 1) {\n      propProxyStates.forEach(([propProxyState, prevRemove], prop) => {\n        if (isDev() && prevRemove) {\n          throw new Error(\"remove already exists\");\n        }\n        const remove = propProxyState[3](createPropListener(prop));\n        propProxyStates.set(prop, [propProxyState, remove]);\n      });\n    }\n    const removeListener = () => {\n      listeners.delete(listener);\n      if (listeners.size === 0) {\n        propProxyStates.forEach(([propProxyState, remove], prop) => {\n          if (remove) {\n            remove();\n            propProxyStates.set(prop, [propProxyState]);\n          }\n        });\n      }\n    };\n    return removeListener;\n  };\n  const baseObject = Array.isArray(initialObject) ? [] : Object.create(Object.getPrototypeOf(initialObject));\n  const handler = {\n    deleteProperty(target, prop) {\n      const prevValue = Reflect.get(target, prop);\n      removePropListener(prop);\n      const deleted = Reflect.deleteProperty(target, prop);\n      if (deleted) {\n        notifyUpdate([\"delete\", [prop], prevValue]);\n      }\n      return deleted;\n    },\n    set(target, prop, value, receiver) {\n      const hasPrevValue = Reflect.has(target, prop);\n      const prevValue = Reflect.get(target, prop, receiver);\n      if (hasPrevValue && (objectIs(prevValue, value) || proxyCache.has(value) && objectIs(prevValue, proxyCache.get(value)))) {\n        return true;\n      }\n      removePropListener(prop);\n      if (isObject(value)) {\n        value = getUntracked(value) || value;\n      }\n      let nextValue = value;\n      if (Object.getOwnPropertyDescriptor(target, prop)?.set) {} else if (value instanceof Promise) {\n        value.then(v => {\n          Object.assign(value, {\n            status: \"fulfilled\",\n            value: v\n          });\n          notifyUpdate([\"resolve\", [prop], v]);\n        }).catch(e => {\n          Object.assign(value, {\n            status: \"rejected\",\n            reason: e\n          });\n          notifyUpdate([\"reject\", [prop], e]);\n        });\n      } else {\n        if (!proxyStateMap.has(value) && canProxy(value)) {\n          nextValue = proxy(value);\n        }\n        const childProxyState = !refSet.has(nextValue) && proxyStateMap.get(nextValue);\n        if (childProxyState) {\n          addPropListener(prop, childProxyState);\n        }\n      }\n      Reflect.set(target, prop, nextValue, receiver);\n      notifyUpdate([\"set\", [prop], value, prevValue]);\n      return true;\n    }\n  };\n  const proxyObject = newProxy(baseObject, handler);\n  proxyCache.set(initialObject, proxyObject);\n  const proxyState = [baseObject, ensureVersion, createSnapshot, addListener];\n  proxyStateMap.set(proxyObject, proxyState);\n  Reflect.ownKeys(initialObject).forEach(key => {\n    const desc = Object.getOwnPropertyDescriptor(initialObject, key);\n    if (desc.get || desc.set) {\n      Object.defineProperty(baseObject, key, desc);\n    } else {\n      proxyObject[key] = initialObject[key];\n    }\n  });\n  return proxyObject;\n}) => [\n// public functions\nproxyFunction2,\n// shared state\nproxyStateMap, refSet,\n// internal things\nobjectIs, newProxy, canProxy, defaultHandlePromise, snapCache, createSnapshot, proxyCache, versionHolder];\nvar [proxyFunction] = buildProxyFunction();\nfunction proxy(initialObject = {}) {\n  return proxyFunction(initialObject);\n}\nfunction subscribe(proxyObject, callback, notifyInSync) {\n  const proxyState = proxyStateMap.get(proxyObject);\n  if (isDev() && !proxyState) {\n    console.warn(\"Please use proxy object\");\n  }\n  let promise;\n  const ops = [];\n  const addListener = proxyState[3];\n  let isListenerActive = false;\n  const listener = op => {\n    ops.push(op);\n    if (notifyInSync) {\n      callback(ops.splice(0));\n      return;\n    }\n    if (!promise) {\n      promise = Promise.resolve().then(() => {\n        promise = void 0;\n        if (isListenerActive) {\n          callback(ops.splice(0));\n        }\n      });\n    }\n  };\n  const removeListener = addListener(listener);\n  isListenerActive = true;\n  return () => {\n    isListenerActive = false;\n    removeListener();\n  };\n}\nfunction snapshot(proxyObject, handlePromise) {\n  const proxyState = proxyStateMap.get(proxyObject);\n  if (isDev() && !proxyState) {\n    console.warn(\"Please use proxy object\");\n  }\n  const [target, ensureVersion, createSnapshot] = proxyState;\n  return createSnapshot(target, ensureVersion(), handlePromise);\n}\nfunction ref(obj) {\n  refSet.add(obj);\n  return obj;\n}\n\n// src/proxy-computed.ts\nfunction proxyWithComputed(initialObject, computedFns) {\n  const keys = Object.keys(computedFns);\n  keys.forEach(key => {\n    if (Object.getOwnPropertyDescriptor(initialObject, key)) {\n      throw new Error(\"object property already defined\");\n    }\n    const computedFn = computedFns[key];\n    const {\n      get,\n      set\n    } = typeof computedFn === \"function\" ? {\n      get: computedFn\n    } : computedFn;\n    const desc = {};\n    desc.get = () => get(snapshot(proxyObject));\n    if (set) {\n      desc.set = newValue => set(proxyObject, newValue);\n    }\n    Object.defineProperty(initialObject, key, desc);\n  });\n  const proxyObject = proxy(initialObject);\n  return proxyObject;\n}\nexport { makeGlobal, proxy, proxyWithComputed, ref, snapshot, subscribe };","map":{"version":3,"names":["getGlobal","globalThis","self","window","global","makeGlobal","key","value","g","getUntracked","markToTrack","isDev","process","env","NODE_ENV","isObject","x","proxyStateMap","WeakMap","refSet","WeakSet","buildProxyFunction","objectIs","Object","is","newProxy","target","handler","Proxy","canProxy","has","Array","isArray","Symbol","iterator","Error","Number","Date","String","RegExp","ArrayBuffer","defaultHandlePromise","promise","status","reason","snapCache","createSnapshot","version","handlePromise","cache","get","snap","create","getPrototypeOf","set","Reflect","ownKeys","forEach","Promise","defineProperty","snapshot","freeze","proxyCache","versionHolder","proxyFunction2","initialObject","found","listeners","Set","notifyUpdate","op","nextVersion","listener","checkVersion","ensureVersion","nextCheckVersion","size","propProxyStates","propProxyState","propVersion","createPropListener","prop","newOp","Map","addPropListener","remove","removePropListener","entry","delete","addListener","add","prevRemove","removeListener","baseObject","deleteProperty","prevValue","deleted","receiver","hasPrevValue","nextValue","getOwnPropertyDescriptor","then","v","assign","catch","e","proxy","childProxyState","proxyObject","proxyState","desc","proxyFunction","subscribe","callback","notifyInSync","console","warn","ops","isListenerActive","push","splice","resolve","ref","obj","proxyWithComputed","computedFns","keys","computedFn","newValue"],"sources":["C:\\Users\\lab_services_student\\Desktop\\PartThree\\frontend\\node_modules\\@zag-js\\toast\\node_modules\\@zag-js\\store\\src\\global.ts","C:\\Users\\lab_services_student\\Desktop\\PartThree\\frontend\\node_modules\\@zag-js\\toast\\node_modules\\@zag-js\\store\\src\\proxy.ts","C:\\Users\\lab_services_student\\Desktop\\PartThree\\frontend\\node_modules\\@zag-js\\toast\\node_modules\\@zag-js\\store\\src\\proxy-computed.ts"],"sourcesContent":["function getGlobal(): any {\n  if (typeof globalThis !== \"undefined\") return globalThis\n  if (typeof self !== \"undefined\") return self\n  if (typeof window !== \"undefined\") return window\n  if (typeof global !== \"undefined\") return global\n}\n\nexport function makeGlobal<T>(key: string, value: () => T): T {\n  const g = getGlobal()\n  if (!g) return value()\n  g[key] ||= value()\n  return g[key]\n}\n","// Credits: https://github.com/pmndrs/valtio\n\nimport { getUntracked, markToTrack } from \"proxy-compare\"\nimport { makeGlobal } from \"./global\"\n\nconst isDev = () => process.env.NODE_ENV !== \"production\"\nconst isObject = (x: unknown): x is object => typeof x === \"object\" && x !== null\n\ntype AsRef = { $$valtioRef: true }\n\ntype ProxyObject = object\n\ntype Path = (string | symbol)[]\n\ntype Op =\n  | [op: \"set\", path: Path, value: unknown, prevValue: unknown]\n  | [op: \"delete\", path: Path, prevValue: unknown]\n  | [op: \"resolve\", path: Path, value: unknown]\n  | [op: \"reject\", path: Path, error: unknown]\n\ntype Listener = (op: Op, nextVersion: number) => void\n\ntype AnyFunction = (...args: any[]) => any\n\nexport type Snapshot<T> = T extends AnyFunction\n  ? T\n  : T extends AsRef\n    ? T\n    : T extends Promise<any>\n      ? Awaited<T>\n      : {\n          readonly [K in keyof T]: Snapshot<T[K]>\n        }\n\ntype HandlePromise = <P extends Promise<any>>(promise: P) => Awaited<P>\n\ntype CreateSnapshot = <T extends object>(target: T, version: number, handlePromise?: HandlePromise) => T\n\ntype RemoveListener = () => void\ntype AddListener = (listener: Listener) => RemoveListener\n\ntype ProxyState = readonly [\n  target: object,\n  ensureVersion: (nextCheckVersion?: number) => number,\n  createSnapshot: CreateSnapshot,\n  addListener: AddListener,\n]\n\n// shared state\nconst proxyStateMap = makeGlobal(\"__zag__proxyStateMap\", () => new WeakMap<ProxyObject, ProxyState>())\nconst refSet = makeGlobal(\"__zag__refSet\", () => new WeakSet())\n\nconst buildProxyFunction = (\n  objectIs = Object.is,\n\n  newProxy = <T extends object>(target: T, handler: ProxyHandler<T>): T => new Proxy(target, handler),\n\n  canProxy = (x: unknown) =>\n    isObject(x) &&\n    !refSet.has(x) &&\n    (Array.isArray(x) || !(Symbol.iterator in x)) &&\n    !(x instanceof WeakMap) &&\n    !(x instanceof WeakSet) &&\n    !(x instanceof Error) &&\n    !(x instanceof Number) &&\n    !(x instanceof Date) &&\n    !(x instanceof String) &&\n    !(x instanceof RegExp) &&\n    !(x instanceof ArrayBuffer),\n\n  defaultHandlePromise = <P extends Promise<any>>(\n    promise: P & {\n      status?: \"pending\" | \"fulfilled\" | \"rejected\"\n      value?: Awaited<P>\n      reason?: unknown\n    },\n  ) => {\n    switch (promise.status) {\n      case \"fulfilled\":\n        return promise.value as Awaited<P>\n      case \"rejected\":\n        throw promise.reason\n      default:\n        throw promise\n    }\n  },\n\n  snapCache = new WeakMap<object, [version: number, snap: unknown]>(),\n\n  createSnapshot: CreateSnapshot = <T extends object>(\n    target: T,\n    version: number,\n    handlePromise: HandlePromise = defaultHandlePromise,\n  ): T => {\n    const cache = snapCache.get(target)\n    if (cache?.[0] === version) {\n      return cache[1] as T\n    }\n    const snap: any = Array.isArray(target) ? [] : Object.create(Object.getPrototypeOf(target))\n    markToTrack(snap, true) // mark to track\n    snapCache.set(target, [version, snap])\n    Reflect.ownKeys(target).forEach((key) => {\n      const value = Reflect.get(target, key)\n      if (refSet.has(value as object)) {\n        markToTrack(value as object, false) // mark not to track\n        snap[key] = value\n      } else if (value instanceof Promise) {\n        Object.defineProperty(snap, key, {\n          get() {\n            return handlePromise(value)\n          },\n        })\n      } else if (proxyStateMap.has(value as object)) {\n        snap[key] = snapshot(value as object, handlePromise)\n      } else {\n        snap[key] = value\n      }\n    })\n    return Object.freeze(snap)\n  },\n\n  proxyCache = new WeakMap<object, ProxyObject>(),\n\n  versionHolder = [1, 1] as [number, number],\n\n  proxyFunction = <T extends object>(initialObject: T): T => {\n    if (!isObject(initialObject)) {\n      throw new Error(\"object required\")\n    }\n    const found = proxyCache.get(initialObject) as T | undefined\n    if (found) {\n      return found\n    }\n    let version = versionHolder[0]\n    const listeners = new Set<Listener>()\n    const notifyUpdate = (op: Op, nextVersion = ++versionHolder[0]) => {\n      if (version !== nextVersion) {\n        version = nextVersion\n        listeners.forEach((listener) => listener(op, nextVersion))\n      }\n    }\n    let checkVersion = versionHolder[1]\n    const ensureVersion = (nextCheckVersion = ++versionHolder[1]) => {\n      if (checkVersion !== nextCheckVersion && !listeners.size) {\n        checkVersion = nextCheckVersion\n        propProxyStates.forEach(([propProxyState]) => {\n          const propVersion = propProxyState[1](nextCheckVersion)\n          if (propVersion > version) {\n            version = propVersion\n          }\n        })\n      }\n      return version\n    }\n    const createPropListener =\n      (prop: string | symbol): Listener =>\n      (op, nextVersion) => {\n        const newOp: Op = [...op]\n        newOp[1] = [prop, ...(newOp[1] as Path)]\n        notifyUpdate(newOp, nextVersion)\n      }\n    const propProxyStates = new Map<string | symbol, readonly [ProxyState, RemoveListener?]>()\n    const addPropListener = (prop: string | symbol, propProxyState: ProxyState) => {\n      if (isDev() && propProxyStates.has(prop)) {\n        throw new Error(\"prop listener already exists\")\n      }\n      if (listeners.size) {\n        const remove = propProxyState[3](createPropListener(prop))\n        propProxyStates.set(prop, [propProxyState, remove])\n      } else {\n        propProxyStates.set(prop, [propProxyState])\n      }\n    }\n    const removePropListener = (prop: string | symbol) => {\n      const entry = propProxyStates.get(prop)\n      if (entry) {\n        propProxyStates.delete(prop)\n        entry[1]?.()\n      }\n    }\n    const addListener = (listener: Listener) => {\n      listeners.add(listener)\n      if (listeners.size === 1) {\n        propProxyStates.forEach(([propProxyState, prevRemove], prop) => {\n          if (isDev() && prevRemove) {\n            throw new Error(\"remove already exists\")\n          }\n          const remove = propProxyState[3](createPropListener(prop))\n          propProxyStates.set(prop, [propProxyState, remove])\n        })\n      }\n      const removeListener = () => {\n        listeners.delete(listener)\n        if (listeners.size === 0) {\n          propProxyStates.forEach(([propProxyState, remove], prop) => {\n            if (remove) {\n              remove()\n              propProxyStates.set(prop, [propProxyState])\n            }\n          })\n        }\n      }\n      return removeListener\n    }\n    const baseObject = Array.isArray(initialObject) ? [] : Object.create(Object.getPrototypeOf(initialObject))\n    const handler: ProxyHandler<T> = {\n      deleteProperty(target: T, prop: string | symbol) {\n        const prevValue = Reflect.get(target, prop)\n        removePropListener(prop)\n        const deleted = Reflect.deleteProperty(target, prop)\n        if (deleted) {\n          notifyUpdate([\"delete\", [prop], prevValue])\n        }\n        return deleted\n      },\n      set(target: T, prop: string | symbol, value: any, receiver: object) {\n        const hasPrevValue = Reflect.has(target, prop)\n        const prevValue = Reflect.get(target, prop, receiver)\n        if (\n          hasPrevValue &&\n          (objectIs(prevValue, value) || (proxyCache.has(value) && objectIs(prevValue, proxyCache.get(value))))\n        ) {\n          return true\n        }\n        removePropListener(prop)\n        if (isObject(value)) {\n          value = getUntracked(value) || value\n        }\n        let nextValue = value\n        if (Object.getOwnPropertyDescriptor(target, prop)?.set) {\n          // do nothing\n        } else if (value instanceof Promise) {\n          value\n            .then((v) => {\n              Object.assign(value, { status: \"fulfilled\", value: v })\n              notifyUpdate([\"resolve\", [prop], v])\n            })\n            .catch((e) => {\n              Object.assign(value, { status: \"rejected\", reason: e })\n              notifyUpdate([\"reject\", [prop], e])\n            })\n        } else {\n          if (!proxyStateMap.has(value) && canProxy(value)) {\n            nextValue = proxy(value)\n          }\n          const childProxyState = !refSet.has(nextValue) && proxyStateMap.get(nextValue)\n          if (childProxyState) {\n            addPropListener(prop, childProxyState)\n          }\n        }\n        Reflect.set(target, prop, nextValue, receiver)\n        notifyUpdate([\"set\", [prop], value, prevValue])\n        return true\n      },\n    }\n    const proxyObject = newProxy(baseObject, handler)\n    proxyCache.set(initialObject, proxyObject)\n    const proxyState: ProxyState = [baseObject, ensureVersion, createSnapshot, addListener]\n    proxyStateMap.set(proxyObject, proxyState)\n    Reflect.ownKeys(initialObject).forEach((key) => {\n      const desc = Object.getOwnPropertyDescriptor(initialObject, key) as PropertyDescriptor\n      if (desc.get || desc.set) {\n        Object.defineProperty(baseObject, key, desc)\n      } else {\n        proxyObject[key as keyof T] = initialObject[key as keyof T]\n      }\n    })\n    return proxyObject\n  },\n) =>\n  [\n    // public functions\n    proxyFunction,\n    // shared state\n    proxyStateMap,\n    refSet,\n    // internal things\n    objectIs,\n    newProxy,\n    canProxy,\n    defaultHandlePromise,\n    snapCache,\n    createSnapshot,\n    proxyCache,\n    versionHolder,\n  ] as const\n\nconst [proxyFunction] = buildProxyFunction()\n\nexport function proxy<T extends object>(initialObject: T = {} as T): T {\n  return proxyFunction(initialObject)\n}\n\nexport function getVersion(proxyObject: unknown): number | undefined {\n  const proxyState = proxyStateMap.get(proxyObject as object)\n  return proxyState?.[1]()\n}\n\nexport function subscribe<T extends object>(\n  proxyObject: T,\n  callback: (ops: Op[]) => void,\n  notifyInSync?: boolean,\n): () => void {\n  const proxyState = proxyStateMap.get(proxyObject as object)\n  if (isDev() && !proxyState) {\n    console.warn(\"Please use proxy object\")\n  }\n  let promise: Promise<void> | undefined\n  const ops: Op[] = []\n  const addListener = (proxyState as ProxyState)[3]\n  let isListenerActive = false\n  const listener: Listener = (op) => {\n    ops.push(op)\n    if (notifyInSync) {\n      callback(ops.splice(0))\n      return\n    }\n    if (!promise) {\n      promise = Promise.resolve().then(() => {\n        promise = undefined\n        if (isListenerActive) {\n          callback(ops.splice(0))\n        }\n      })\n    }\n  }\n  const removeListener = addListener(listener)\n  isListenerActive = true\n  return () => {\n    isListenerActive = false\n    removeListener()\n  }\n}\n\nexport function snapshot<T extends object>(proxyObject: T, handlePromise?: HandlePromise): Snapshot<T> {\n  const proxyState = proxyStateMap.get(proxyObject as object)\n  if (isDev() && !proxyState) {\n    console.warn(\"Please use proxy object\")\n  }\n  const [target, ensureVersion, createSnapshot] = proxyState as ProxyState\n  return createSnapshot(target, ensureVersion(), handlePromise) as Snapshot<T>\n}\n\nexport function ref<T extends object>(obj: T): Ref<T> {\n  refSet.add(obj)\n  return obj as T & AsRef\n}\n\nexport type Ref<T> = T & AsRef\n","import { proxy, snapshot, type Snapshot } from \"./proxy\"\n\nexport function proxyWithComputed<T extends object, U extends object>(\n  initialObject: T,\n  computedFns: {\n    [K in keyof U]:\n      | ((snap: Snapshot<T>) => U[K])\n      | {\n          get: (snap: Snapshot<T>) => U[K]\n          set?: (state: T, newValue: U[K]) => void\n        }\n  },\n) {\n  const keys = Object.keys(computedFns) as (keyof U)[]\n  keys.forEach((key) => {\n    if (Object.getOwnPropertyDescriptor(initialObject, key)) {\n      throw new Error(\"object property already defined\")\n    }\n    const computedFn = computedFns[key]\n    const { get, set } = (typeof computedFn === \"function\" ? { get: computedFn } : computedFn) as {\n      get: (snap: Snapshot<T>) => U[typeof key]\n      set?: (state: T, newValue: U[typeof key]) => void\n    }\n    const desc: PropertyDescriptor = {}\n    desc.get = () => get(snapshot(proxyObject))\n    if (set) {\n      desc.set = (newValue) => set(proxyObject, newValue)\n    }\n    Object.defineProperty(initialObject, key, desc)\n  })\n  const proxyObject = proxy(initialObject) as T & U\n  return proxyObject\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
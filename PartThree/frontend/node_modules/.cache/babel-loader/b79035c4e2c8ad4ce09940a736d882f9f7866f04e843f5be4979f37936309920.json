{"ast":null,"code":"// src/add-dom-event.ts\nvar addDomEvent = (target, eventName, handler, options) => {\n  const node = typeof target === \"function\" ? target() : target;\n  node?.addEventListener(eventName, handler, options);\n  return () => {\n    node?.removeEventListener(eventName, handler, options);\n  };\n};\n\n// src/assertion.ts\nimport { isMac } from \"@zag-js/dom-query\";\nfunction isKeyboardClick(e) {\n  return e.detail === 0 || e.clientX === 0 && e.clientY === 0;\n}\nfunction isPrintableKey(e) {\n  return e.key.length === 1 && !e.ctrlKey && !e.metaKey;\n}\nfunction isVirtualPointerEvent(e) {\n  return e.width === 0 && e.height === 0 || e.width === 1 && e.height === 1 && e.pressure === 0 && e.detail === 0 && e.pointerType === \"mouse\";\n}\nfunction isVirtualClick(e) {\n  if (e.mozInputSource === 0 && e.isTrusted) return true;\n  return e.detail === 0 && !e.pointerType;\n}\nvar isLeftClick = e => e.button === 0;\nvar isContextMenuEvent = e => {\n  return e.button === 2 || isMac() && e.ctrlKey && e.button === 0;\n};\nvar isModifierKey = e => e.ctrlKey || e.altKey || e.metaKey;\n\n// src/click-link.ts\nimport { isFirefox } from \"@zag-js/dom-query\";\n\n// src/queue-before-event.ts\nfunction queueBeforeEvent(element, type, cb) {\n  const createTimer = callback => {\n    const timerId = requestAnimationFrame(callback);\n    return () => cancelAnimationFrame(timerId);\n  };\n  const cancelTimer = createTimer(() => {\n    element.removeEventListener(type, callSync, true);\n    cb();\n  });\n  const callSync = () => {\n    cancelTimer();\n    cb();\n  };\n  element.addEventListener(type, callSync, {\n    once: true,\n    capture: true\n  });\n  return cancelTimer;\n}\n\n// src/click-link.ts\nfunction isLinkElement(element) {\n  return element?.matches(\"a[href]\") ?? false;\n}\nfunction clickIfLink(element) {\n  if (!isLinkElement(element)) return;\n  const click = () => element.click();\n  if (isFirefox()) {\n    queueBeforeEvent(element, \"keyup\", click);\n  } else {\n    queueMicrotask(click);\n  }\n}\n\n// src/fire-event.ts\nfunction fireCustomEvent(el, type, init) {\n  if (!el) return;\n  const win = el.ownerDocument.defaultView || window;\n  const event = new win.CustomEvent(type, init);\n  return el.dispatchEvent(event);\n}\nfunction fireBlurEvent(el, init) {\n  const win = el.ownerDocument.defaultView || window;\n  const event = new win.FocusEvent(\"blur\", init);\n  const allowed = el.dispatchEvent(event);\n  const bubbleInit = {\n    ...init,\n    bubbles: true\n  };\n  el.dispatchEvent(new win.FocusEvent(\"focusout\", bubbleInit));\n  return allowed;\n}\n\n// src/get-event-key.ts\nvar keyMap = {\n  Up: \"ArrowUp\",\n  Down: \"ArrowDown\",\n  Esc: \"Escape\",\n  \" \": \"Space\",\n  \",\": \"Comma\",\n  Left: \"ArrowLeft\",\n  Right: \"ArrowRight\"\n};\nvar rtlKeyMap = {\n  ArrowLeft: \"ArrowRight\",\n  ArrowRight: \"ArrowLeft\"\n};\nfunction getEventKey(event, options = {}) {\n  const {\n    dir = \"ltr\",\n    orientation = \"horizontal\"\n  } = options;\n  let {\n    key\n  } = event;\n  key = keyMap[key] ?? key;\n  const isRtl = dir === \"rtl\" && orientation === \"horizontal\";\n  if (isRtl && key in rtlKeyMap) {\n    key = rtlKeyMap[key];\n  }\n  return key;\n}\n\n// src/get-event-point.ts\nfunction pointFromTouch(e, type = \"client\") {\n  const point = e.touches[0] || e.changedTouches[0];\n  return {\n    x: point[`${type}X`],\n    y: point[`${type}Y`]\n  };\n}\nfunction pointFromMouse(point, type = \"client\") {\n  return {\n    x: point[`${type}X`],\n    y: point[`${type}Y`]\n  };\n}\nvar isTouchEvent = event => \"touches\" in event && event.touches.length > 0;\nfunction getEventPoint(event, type = \"client\") {\n  return isTouchEvent(event) ? pointFromTouch(event, type) : pointFromMouse(event, type);\n}\n\n// src/get-event-step.ts\nvar PAGE_KEYS = /* @__PURE__ */new Set([\"PageUp\", \"PageDown\"]);\nvar ARROW_KEYS = /* @__PURE__ */new Set([\"ArrowUp\", \"ArrowDown\", \"ArrowLeft\", \"ArrowRight\"]);\nfunction getEventStep(event) {\n  if (event.ctrlKey || event.metaKey) {\n    return 0.1;\n  } else {\n    const isPageKey = PAGE_KEYS.has(event.key);\n    const isSkipKey = isPageKey || event.shiftKey && ARROW_KEYS.has(event.key);\n    return isSkipKey ? 10 : 1;\n  }\n}\n\n// src/get-native-event.ts\nfunction getNativeEvent(event) {\n  return event.nativeEvent ?? event;\n}\n\n// src/get-point-value.ts\nfunction clamp(value) {\n  return Math.max(0, Math.min(1, value));\n}\nfunction getRelativePoint(point, element) {\n  const {\n    left,\n    top,\n    width,\n    height\n  } = element.getBoundingClientRect();\n  const offset = {\n    x: point.x - left,\n    y: point.y - top\n  };\n  const percent = {\n    x: clamp(offset.x / width),\n    y: clamp(offset.y / height)\n  };\n  function getPercentValue(options = {}) {\n    const {\n      dir = \"ltr\",\n      orientation = \"horizontal\",\n      inverted\n    } = options;\n    const invertX = typeof inverted === \"object\" ? inverted.x : inverted;\n    const invertY = typeof inverted === \"object\" ? inverted.y : inverted;\n    if (orientation === \"horizontal\") {\n      return dir === \"rtl\" || invertX ? 1 - percent.x : percent.x;\n    }\n    return invertY ? 1 - percent.y : percent.y;\n  }\n  return {\n    offset,\n    percent,\n    getPercentValue\n  };\n}\n\n// src/request-pointer-lock.ts\nfunction requestPointerLock(doc, fn) {\n  const body = doc.body;\n  const supported = \"pointerLockElement\" in doc || \"mozPointerLockElement\" in doc;\n  const isLocked = () => !!doc.pointerLockElement;\n  function onPointerChange() {\n    fn?.(isLocked());\n  }\n  function onPointerError(event) {\n    if (isLocked()) fn?.(false);\n    console.error(\"PointerLock error occured:\", event);\n    doc.exitPointerLock();\n  }\n  if (!supported) return;\n  try {\n    body.requestPointerLock();\n  } catch {}\n  const cleanup = [addDomEvent(doc, \"pointerlockchange\", onPointerChange, false), addDomEvent(doc, \"pointerlockerror\", onPointerError, false)];\n  return () => {\n    cleanup.forEach(cleanup2 => cleanup2());\n    doc.exitPointerLock();\n  };\n}\n\n// src/track-focus-visible.ts\nimport { getWindow, isMac as isMac2 } from \"@zag-js/dom-query\";\n\n// src/pipe.ts\nvar pipe = (...fns) => arg => fns.reduce((acc, fn) => fn(acc), arg);\nvar noop = () => void 0;\n\n// src/track-focus-visible.ts\nvar isValidKey = e => {\n  return !(e.metaKey || !isMac2() && e.altKey || e.ctrlKey || e.key === \"Control\" || e.key === \"Shift\" || e.key === \"Meta\");\n};\nfunction trackFocusVisible(node, options) {\n  if (!node) return;\n  const {\n    onFocus,\n    onBlur\n  } = options;\n  const win = getWindow(node);\n  let focused = false;\n  const handleFocus = e => {\n    let isFocusVisible = false;\n    try {\n      isFocusVisible = node.matches(\":focus-visible\");\n    } catch {\n      isFocusVisible = true;\n    }\n    if (!isFocusVisible) return;\n    focused = true;\n    onFocus?.(e);\n  };\n  const handleBlur = e => {\n    if (!focused) return;\n    focused = false;\n    onBlur?.(e);\n  };\n  const handleKeydown = e => {\n    if (!node.matches(\":focus\") || !isValidKey(e)) return;\n    focused = true;\n    const evt = new win.FocusEvent(\"focus\");\n    onFocus?.(evt);\n  };\n  return pipe(addDomEvent(node, \"focusin\", handleFocus), addDomEvent(node, \"focusout\", handleBlur), addDomEvent(node, \"keydown\", handleKeydown, true));\n}\n\n// src/track-pointer-move.ts\nimport { disableTextSelection } from \"@zag-js/text-selection\";\nfunction trackPointerMove(doc, handlers) {\n  const {\n    onPointerMove,\n    onPointerUp\n  } = handlers;\n  const history = [];\n  const handleMove = event => {\n    const point = getEventPoint(event);\n    history.push({\n      ...point,\n      timestamp: performance.now()\n    });\n    const distance = Math.sqrt(point.x ** 2 + point.y ** 2);\n    const moveBuffer = event.pointerType === \"touch\" ? 10 : 5;\n    if (distance < moveBuffer) return;\n    if (event.pointerType === \"mouse\" && event.button === 0) {\n      onPointerUp();\n      return;\n    }\n    onPointerMove({\n      point,\n      event,\n      velocity: getVelocity(history, 0.1)\n    });\n  };\n  const cleanups = [addDomEvent(doc, \"pointermove\", handleMove, false), addDomEvent(doc, \"pointerup\", onPointerUp, false), addDomEvent(doc, \"pointercancel\", onPointerUp, false), addDomEvent(doc, \"contextmenu\", onPointerUp, false), disableTextSelection({\n    doc\n  })];\n  return () => {\n    cleanups.forEach(cleanup => cleanup());\n    history.length = 0;\n  };\n}\nfunction lastDevicePoint(history) {\n  return history[history.length - 1];\n}\nfunction ms(seconds) {\n  return seconds * 1e3;\n}\nfunction sec(milliseconds) {\n  return milliseconds / 1e3;\n}\nfunction getVelocity(history, timeDelta) {\n  if (history.length < 2) return {\n    x: 0,\n    y: 0\n  };\n  let i = history.length - 1;\n  let timestampedPoint = null;\n  const lastPoint = lastDevicePoint(history);\n  while (i >= 0) {\n    timestampedPoint = history[i];\n    if (lastPoint.timestamp - timestampedPoint.timestamp > ms(timeDelta)) {\n      break;\n    }\n    i--;\n  }\n  if (!timestampedPoint) return {\n    x: 0,\n    y: 0\n  };\n  const time = sec(lastPoint.timestamp - timestampedPoint.timestamp);\n  if (time === 0) return {\n    x: 0,\n    y: 0\n  };\n  const currentVelocity = {\n    x: (lastPoint.x - timestampedPoint.x) / time,\n    y: (lastPoint.y - timestampedPoint.y) / time\n  };\n  if (currentVelocity.x === Infinity) currentVelocity.x = 0;\n  if (currentVelocity.y === Infinity) currentVelocity.y = 0;\n  return {\n    x: Math.abs(currentVelocity.x),\n    y: Math.abs(currentVelocity.y)\n  };\n}\n\n// src/track-press.ts\nimport { contains, getDocument, getEventTarget, getWindow as getWindow2 } from \"@zag-js/dom-query\";\nfunction trackPress(options) {\n  const {\n    pointerNode,\n    keyboardNode = pointerNode,\n    onPress,\n    onPressStart,\n    onPressEnd,\n    isValidKey: isValidKey2 = e => e.key === \"Enter\"\n  } = options;\n  if (!pointerNode) return noop;\n  const win = getWindow2(pointerNode);\n  const doc = getDocument(pointerNode);\n  let removeStartListeners = noop;\n  let removeEndListeners = noop;\n  let removeAccessibleListeners = noop;\n  const getInfo = event => ({\n    point: getEventPoint(event),\n    event\n  });\n  function startPress(event) {\n    onPressStart?.(getInfo(event));\n  }\n  function cancelPress(event) {\n    onPressEnd?.(getInfo(event));\n  }\n  const startPointerPress = startEvent => {\n    removeEndListeners();\n    const endPointerPress = endEvent => {\n      const target = getEventTarget(endEvent);\n      if (contains(pointerNode, target)) {\n        onPress?.(getInfo(endEvent));\n      } else {\n        onPressEnd?.(getInfo(endEvent));\n      }\n    };\n    const removePointerUpListener = addDomEvent(win, \"pointerup\", endPointerPress, {\n      passive: !onPress\n    });\n    const removePointerCancelListener = addDomEvent(win, \"pointercancel\", cancelPress, {\n      passive: !onPressEnd\n    });\n    removeEndListeners = pipe(removePointerUpListener, removePointerCancelListener);\n    if (doc.activeElement === keyboardNode && startEvent.pointerType === \"mouse\") {\n      startEvent.preventDefault();\n    }\n    startPress(startEvent);\n  };\n  const removePointerListener = addDomEvent(pointerNode, \"pointerdown\", startPointerPress, {\n    passive: !onPressStart\n  });\n  const removeFocusListener = addDomEvent(keyboardNode, \"focus\", startAccessiblePress);\n  removeStartListeners = pipe(removePointerListener, removeFocusListener);\n  function startAccessiblePress() {\n    const handleKeydown = keydownEvent => {\n      if (!isValidKey2(keydownEvent)) return;\n      const handleKeyup = keyupEvent => {\n        if (!isValidKey2(keyupEvent)) return;\n        const evt2 = new win.PointerEvent(\"pointerup\");\n        const info = getInfo(evt2);\n        onPress?.(info);\n        onPressEnd?.(info);\n      };\n      removeEndListeners();\n      removeEndListeners = addDomEvent(keyboardNode, \"keyup\", handleKeyup);\n      const evt = new win.PointerEvent(\"pointerdown\");\n      startPress(evt);\n    };\n    const handleBlur = () => {\n      const evt = new win.PointerEvent(\"pointercancel\");\n      cancelPress(evt);\n    };\n    const removeKeydownListener = addDomEvent(keyboardNode, \"keydown\", handleKeydown);\n    const removeBlurListener = addDomEvent(keyboardNode, \"blur\", handleBlur);\n    removeAccessibleListeners = pipe(removeKeydownListener, removeBlurListener);\n  }\n  return function () {\n    removeStartListeners();\n    removeEndListeners();\n    removeAccessibleListeners();\n  };\n}\n\n// src/track-visual-viewport.ts\nfunction trackVisualViewport(doc, fn) {\n  const win = doc?.defaultView || window;\n  const onResize = () => {\n    fn?.(getViewportSize(win));\n  };\n  onResize();\n  return addDomEvent(win.visualViewport ?? win, \"resize\", onResize);\n}\nfunction getViewportSize(win) {\n  return {\n    width: win.visualViewport?.width || win.innerWidth,\n    height: win.visualViewport?.height || win.innerHeight\n  };\n}\nexport { addDomEvent, clickIfLink, fireBlurEvent, fireCustomEvent, getEventKey, getEventPoint, getEventStep, getNativeEvent, getRelativePoint, isContextMenuEvent, isKeyboardClick, isLeftClick, isModifierKey, isPrintableKey, isVirtualClick, isVirtualPointerEvent, queueBeforeEvent, requestPointerLock, trackFocusVisible, trackPointerMove, trackPress, trackVisualViewport };","map":{"version":3,"names":["addDomEvent","target","eventName","handler","options","node","addEventListener","removeEventListener","isMac","isKeyboardClick","e","detail","clientX","clientY","isPrintableKey","key","length","ctrlKey","metaKey","isVirtualPointerEvent","width","height","pressure","pointerType","isVirtualClick","mozInputSource","isTrusted","isLeftClick","button","isContextMenuEvent","isModifierKey","altKey","isFirefox","queueBeforeEvent","element","type","cb","createTimer","callback","timerId","requestAnimationFrame","cancelAnimationFrame","cancelTimer","callSync","once","capture","isLinkElement","matches","clickIfLink","click","queueMicrotask","fireCustomEvent","el","init","win","ownerDocument","defaultView","window","event","CustomEvent","dispatchEvent","fireBlurEvent","FocusEvent","allowed","bubbleInit","bubbles","keyMap","Up","Down","Esc","Left","Right","rtlKeyMap","ArrowLeft","ArrowRight","getEventKey","dir","orientation","isRtl","pointFromTouch","point","touches","changedTouches","x","y","pointFromMouse","isTouchEvent","getEventPoint","PAGE_KEYS","Set","ARROW_KEYS","getEventStep","isPageKey","has","isSkipKey","shiftKey","getNativeEvent","nativeEvent","clamp","value","Math","max","min","getRelativePoint","left","top","getBoundingClientRect","offset","percent","getPercentValue","inverted","invertX","invertY","requestPointerLock","doc","fn","body","supported","isLocked","pointerLockElement","onPointerChange","onPointerError","console","error","exitPointerLock","cleanup","forEach","cleanup2","getWindow","isMac2","pipe","fns","arg","reduce","acc","noop","isValidKey","trackFocusVisible","onFocus","onBlur","focused","handleFocus","isFocusVisible","handleBlur","handleKeydown","evt","disableTextSelection","trackPointerMove","handlers","onPointerMove","onPointerUp","history","handleMove","push","timestamp","performance","now","distance","sqrt","moveBuffer","velocity","getVelocity","cleanups","lastDevicePoint","ms","seconds","sec","milliseconds","timeDelta","i","timestampedPoint","lastPoint","time","currentVelocity","Infinity","abs","contains","getDocument","getEventTarget","getWindow2","trackPress","pointerNode","keyboardNode","onPress","onPressStart","onPressEnd","isValidKey2","removeStartListeners","removeEndListeners","removeAccessibleListeners","getInfo","startPress","cancelPress","startPointerPress","startEvent","endPointerPress","endEvent","removePointerUpListener","passive","removePointerCancelListener","activeElement","preventDefault","removePointerListener","removeFocusListener","startAccessiblePress","keydownEvent","handleKeyup","keyupEvent","evt2","PointerEvent","info","removeKeydownListener","removeBlurListener","trackVisualViewport","onResize","getViewportSize","visualViewport","innerWidth","innerHeight"],"sources":["C:\\Users\\lab_services_student\\Desktop\\PartThree\\frontend\\node_modules\\@zag-js\\dom-event\\src\\add-dom-event.ts","C:\\Users\\lab_services_student\\Desktop\\PartThree\\frontend\\node_modules\\@zag-js\\dom-event\\src\\assertion.ts","C:\\Users\\lab_services_student\\Desktop\\PartThree\\frontend\\node_modules\\@zag-js\\dom-event\\src\\click-link.ts","C:\\Users\\lab_services_student\\Desktop\\PartThree\\frontend\\node_modules\\@zag-js\\dom-event\\src\\queue-before-event.ts","C:\\Users\\lab_services_student\\Desktop\\PartThree\\frontend\\node_modules\\@zag-js\\dom-event\\src\\fire-event.ts","C:\\Users\\lab_services_student\\Desktop\\PartThree\\frontend\\node_modules\\@zag-js\\dom-event\\src\\get-event-key.ts","C:\\Users\\lab_services_student\\Desktop\\PartThree\\frontend\\node_modules\\@zag-js\\dom-event\\src\\get-event-point.ts","C:\\Users\\lab_services_student\\Desktop\\PartThree\\frontend\\node_modules\\@zag-js\\dom-event\\src\\get-event-step.ts","C:\\Users\\lab_services_student\\Desktop\\PartThree\\frontend\\node_modules\\@zag-js\\dom-event\\src\\get-native-event.ts","C:\\Users\\lab_services_student\\Desktop\\PartThree\\frontend\\node_modules\\@zag-js\\dom-event\\src\\get-point-value.ts","C:\\Users\\lab_services_student\\Desktop\\PartThree\\frontend\\node_modules\\@zag-js\\dom-event\\src\\request-pointer-lock.ts","C:\\Users\\lab_services_student\\Desktop\\PartThree\\frontend\\node_modules\\@zag-js\\dom-event\\src\\track-focus-visible.ts","C:\\Users\\lab_services_student\\Desktop\\PartThree\\frontend\\node_modules\\@zag-js\\dom-event\\src\\pipe.ts","C:\\Users\\lab_services_student\\Desktop\\PartThree\\frontend\\node_modules\\@zag-js\\dom-event\\src\\track-pointer-move.ts","C:\\Users\\lab_services_student\\Desktop\\PartThree\\frontend\\node_modules\\@zag-js\\dom-event\\src\\track-press.ts","C:\\Users\\lab_services_student\\Desktop\\PartThree\\frontend\\node_modules\\@zag-js\\dom-event\\src\\track-visual-viewport.ts"],"sourcesContent":["interface EventMap extends DocumentEventMap, WindowEventMap, HTMLElementEventMap {}\n\ntype Node = Document | HTMLElement | EventTarget | null\n\ntype Target = (() => Node) | Node\n\nexport const addDomEvent = <K extends keyof EventMap>(\n  target: Target,\n  eventName: K,\n  handler: (event: EventMap[K]) => void,\n  options?: boolean | AddEventListenerOptions,\n) => {\n  const node = typeof target === \"function\" ? target() : target\n  node?.addEventListener(eventName, handler as any, options)\n  return () => {\n    node?.removeEventListener(eventName, handler as any, options)\n  }\n}\n","import { isMac } from \"@zag-js/dom-query\"\n\nexport function isKeyboardClick(e: Pick<MouseEvent, \"detail\" | \"clientX\" | \"clientY\">) {\n  return e.detail === 0 || (e.clientX === 0 && e.clientY === 0)\n}\n\nexport function isPrintableKey(e: Pick<KeyboardEvent, \"key\" | \"ctrlKey\" | \"metaKey\">): boolean {\n  return e.key.length === 1 && !e.ctrlKey && !e.metaKey\n}\n\nexport function isVirtualPointerEvent(e: PointerEvent) {\n  return (\n    (e.width === 0 && e.height === 0) ||\n    (e.width === 1 && e.height === 1 && e.pressure === 0 && e.detail === 0 && e.pointerType === \"mouse\")\n  )\n}\n\nexport function isVirtualClick(e: MouseEvent | PointerEvent): boolean {\n  if ((e as any).mozInputSource === 0 && e.isTrusted) return true\n  return e.detail === 0 && !(e as PointerEvent).pointerType\n}\n\nexport const isLeftClick = (e: Pick<MouseEvent, \"button\">) => e.button === 0\n\nexport const isContextMenuEvent = (e: Pick<MouseEvent, \"button\" | \"ctrlKey\" | \"metaKey\">) => {\n  return e.button === 2 || (isMac() && e.ctrlKey && e.button === 0)\n}\n\nexport const isModifierKey = (e: Pick<KeyboardEvent, \"ctrlKey\" | \"metaKey\" | \"altKey\">) =>\n  e.ctrlKey || e.altKey || e.metaKey\n","import { isFirefox } from \"@zag-js/dom-query\"\nimport { queueBeforeEvent } from \"./queue-before-event\"\n\nfunction isLinkElement(element: HTMLElement | null | undefined) {\n  return element?.matches(\"a[href]\") ?? false\n}\n\nexport function clickIfLink(element: HTMLElement | null | undefined) {\n  if (!isLinkElement(element)) return\n  const click = () => element!.click()\n  if (isFirefox()) {\n    queueBeforeEvent(element!, \"keyup\", click)\n  } else {\n    queueMicrotask(click)\n  }\n}\n","export function queueBeforeEvent(element: EventTarget, type: string, cb: () => void) {\n  const createTimer = (callback: () => void) => {\n    const timerId = requestAnimationFrame(callback)\n    return () => cancelAnimationFrame(timerId)\n  }\n\n  const cancelTimer = createTimer(() => {\n    element.removeEventListener(type, callSync, true)\n    cb()\n  })\n  const callSync = () => {\n    cancelTimer()\n    cb()\n  }\n\n  element.addEventListener(type, callSync, { once: true, capture: true })\n  return cancelTimer\n}\n","export function fireCustomEvent(el: HTMLElement | null, type: string, init?: CustomEventInit) {\n  if (!el) return\n  const win = el.ownerDocument.defaultView || window\n  const event = new win.CustomEvent(type, init)\n  return el.dispatchEvent(event)\n}\n\nexport function fireBlurEvent(el: HTMLElement, init?: FocusEventInit) {\n  const win = el.ownerDocument.defaultView || window\n  const event = new win.FocusEvent(\"blur\", init)\n  const allowed = el.dispatchEvent(event)\n  const bubbleInit = { ...init, bubbles: true }\n  el.dispatchEvent(new win.FocusEvent(\"focusout\", bubbleInit))\n  return allowed\n}\n","import type { EventKeyOptions } from \"./types\"\n\nconst keyMap: Record<string, string> = {\n  Up: \"ArrowUp\",\n  Down: \"ArrowDown\",\n  Esc: \"Escape\",\n  \" \": \"Space\",\n  \",\": \"Comma\",\n  Left: \"ArrowLeft\",\n  Right: \"ArrowRight\",\n}\n\nconst rtlKeyMap: Record<string, string> = {\n  ArrowLeft: \"ArrowRight\",\n  ArrowRight: \"ArrowLeft\",\n}\n\n/**\n * Determine the event key based on text direction.\n */\nexport function getEventKey(event: Pick<KeyboardEvent, \"key\">, options: EventKeyOptions = {}) {\n  const { dir = \"ltr\", orientation = \"horizontal\" } = options\n\n  let { key } = event\n  key = keyMap[key] ?? key // normalize key\n\n  const isRtl = dir === \"rtl\" && orientation === \"horizontal\"\n\n  if (isRtl && key in rtlKeyMap) {\n    key = rtlKeyMap[key]\n  }\n\n  return key\n}\n","type PointType = \"page\" | \"client\"\n\nfunction pointFromTouch(e: TouchEvent, type: PointType = \"client\") {\n  const point = e.touches[0] || e.changedTouches[0]\n  return { x: point[`${type}X`], y: point[`${type}Y`] }\n}\n\nfunction pointFromMouse(point: MouseEvent | PointerEvent, type: PointType = \"client\") {\n  return { x: point[`${type}X`], y: point[`${type}Y`] }\n}\n\ntype AnyPointerEvent = MouseEvent | TouchEvent | PointerEvent\n\nconst isTouchEvent = (event: AnyPointerEvent): event is TouchEvent => \"touches\" in event && event.touches.length > 0\n\nexport function getEventPoint(event: any, type: PointType = \"client\") {\n  return isTouchEvent(event) ? pointFromTouch(event, type) : pointFromMouse(event, type)\n}\n","const PAGE_KEYS = new Set([\"PageUp\", \"PageDown\"])\nconst ARROW_KEYS = new Set([\"ArrowUp\", \"ArrowDown\", \"ArrowLeft\", \"ArrowRight\"])\n\n/**\n * Determine the step factor for keyboard events\n */\nexport function getEventStep(event: Pick<KeyboardEvent, \"ctrlKey\" | \"metaKey\" | \"key\" | \"shiftKey\">) {\n  if (event.ctrlKey || event.metaKey) {\n    return 0.1\n  } else {\n    const isPageKey = PAGE_KEYS.has(event.key)\n    const isSkipKey = isPageKey || (event.shiftKey && ARROW_KEYS.has(event.key))\n    return isSkipKey ? 10 : 1\n  }\n}\n","import type { JSX } from \"@zag-js/types\"\n\ntype NativeEvent<E> =\n  JSX.ChangeEvent<any> extends E ? InputEvent : E extends JSX.SyntheticEvent<any, infer T> ? T : never\n\nexport function getNativeEvent<E>(event: E): NativeEvent<E> {\n  return (event as any).nativeEvent ?? event\n}\n","function clamp(value: number) {\n  return Math.max(0, Math.min(1, value))\n}\n\nexport type Point = {\n  x: number\n  y: number\n}\n\ntype PercentValueOptions = {\n  inverted?: boolean | { x?: boolean; y?: boolean }\n  dir?: \"ltr\" | \"rtl\"\n  orientation?: \"vertical\" | \"horizontal\"\n}\n\nexport function getRelativePoint(point: Point, element: HTMLElement) {\n  const { left, top, width, height } = element.getBoundingClientRect()\n\n  const offset = { x: point.x - left, y: point.y - top }\n  const percent = { x: clamp(offset.x / width), y: clamp(offset.y / height) }\n\n  function getPercentValue(options: PercentValueOptions = {}) {\n    const { dir = \"ltr\", orientation = \"horizontal\", inverted } = options\n\n    const invertX = typeof inverted === \"object\" ? inverted.x : inverted\n    const invertY = typeof inverted === \"object\" ? inverted.y : inverted\n\n    if (orientation === \"horizontal\") {\n      return dir === \"rtl\" || invertX ? 1 - percent.x : percent.x\n    }\n\n    return invertY ? 1 - percent.y : percent.y\n  }\n\n  return { offset, percent, getPercentValue }\n}\n","import { addDomEvent } from \"./add-dom-event\"\n\nexport function requestPointerLock(doc: Document, fn?: (locked: boolean) => void) {\n  const body = doc.body\n\n  const supported = \"pointerLockElement\" in doc || \"mozPointerLockElement\" in doc\n  const isLocked = () => !!doc.pointerLockElement\n\n  function onPointerChange() {\n    fn?.(isLocked())\n  }\n\n  function onPointerError(event: Event) {\n    if (isLocked()) fn?.(false)\n    console.error(\"PointerLock error occured:\", event)\n    doc.exitPointerLock()\n  }\n\n  if (!supported) return\n\n  try {\n    body.requestPointerLock()\n  } catch {}\n\n  // prettier-ignore\n  const cleanup = [\n    addDomEvent(doc, \"pointerlockchange\", onPointerChange, false),\n    addDomEvent(doc, \"pointerlockerror\", onPointerError, false)\n  ]\n\n  return () => {\n    cleanup.forEach((cleanup) => cleanup())\n    doc.exitPointerLock()\n  }\n}\n","import { getWindow, isMac } from \"@zag-js/dom-query\"\nimport { addDomEvent } from \"./add-dom-event\"\nimport { pipe } from \"./pipe\"\n\nexport interface TrackFocusOptions {\n  /**\n   * Callback to be called when the element receives focus and is focus-visible.\n   */\n  onFocus?(e: FocusEvent): void\n  /**\n   * Callback to be called when the element loses focus.\n   */\n  onBlur?(e: FocusEvent): void\n}\n\nconst isValidKey = (e: KeyboardEvent) => {\n  return !(\n    e.metaKey ||\n    (!isMac() && e.altKey) ||\n    e.ctrlKey ||\n    e.key === \"Control\" ||\n    e.key === \"Shift\" ||\n    e.key === \"Meta\"\n  )\n}\n\nexport function trackFocusVisible(node: Element | null, options: TrackFocusOptions) {\n  if (!node) return\n  const { onFocus, onBlur } = options\n\n  const win = getWindow(node)\n\n  let focused = false\n\n  const handleFocus = (e: FocusEvent) => {\n    let isFocusVisible = false\n\n    try {\n      isFocusVisible = node.matches(\":focus-visible\")\n    } catch {\n      isFocusVisible = true\n    }\n\n    if (!isFocusVisible) return\n\n    focused = true\n    onFocus?.(e)\n  }\n\n  const handleBlur = (e: FocusEvent) => {\n    if (!focused) return\n    focused = false\n    onBlur?.(e)\n  }\n\n  const handleKeydown = (e: KeyboardEvent) => {\n    if (!node.matches(\":focus\") || !isValidKey(e)) return\n    focused = true\n    const evt = new win.FocusEvent(\"focus\")\n    onFocus?.(evt)\n  }\n\n  return pipe(\n    addDomEvent(node, \"focusin\", handleFocus),\n    addDomEvent(node, \"focusout\", handleBlur),\n    addDomEvent(node, \"keydown\", handleKeydown, true),\n  )\n}\n","export const pipe =\n  <T>(...fns: Array<(arg: T) => T>) =>\n  (arg: T) =>\n    fns.reduce((acc, fn) => fn(acc), arg)\n\nexport const noop = () => void 0\n","import { disableTextSelection } from \"@zag-js/text-selection\"\nimport { addDomEvent } from \"./add-dom-event\"\nimport { getEventPoint } from \"./get-event-point\"\n\ninterface Point {\n  x: number\n  y: number\n}\n\ninterface TimestampedPoint extends Point {\n  /**\n   * The time when the point was recorded.\n   */\n  timestamp: number\n}\n\nexport interface PointerMoveDetails {\n  /**\n   * The current position of the pointer.\n   */\n  point: Point\n  /**\n   * The event that triggered the move.\n   */\n  event: PointerEvent\n  /**\n   * The velocity of the pointer on the x and y axis.\n   */\n  velocity: Point\n}\n\nexport interface PointerMoveHandlers {\n  /**\n   * Called when the pointer is released.\n   */\n  onPointerUp: VoidFunction\n  /**\n   * Called when the pointer moves.\n   */\n  onPointerMove: (details: PointerMoveDetails) => void\n}\n\nexport function trackPointerMove(doc: Document, handlers: PointerMoveHandlers) {\n  const { onPointerMove, onPointerUp } = handlers\n\n  const history: TimestampedPoint[] = []\n\n  const handleMove = (event: PointerEvent) => {\n    const point = getEventPoint(event)\n    history.push({ ...point, timestamp: performance.now() })\n\n    const distance = Math.sqrt(point.x ** 2 + point.y ** 2)\n    const moveBuffer = event.pointerType === \"touch\" ? 10 : 5\n\n    if (distance < moveBuffer) return\n\n    // Because Safari doesn't trigger mouseup events when it's above a `<select>`\n    if (event.pointerType === \"mouse\" && event.button === 0) {\n      onPointerUp()\n      return\n    }\n\n    onPointerMove({ point, event, velocity: getVelocity(history, 0.1) })\n  }\n\n  const cleanups = [\n    addDomEvent(doc, \"pointermove\", handleMove, false),\n    addDomEvent(doc, \"pointerup\", onPointerUp, false),\n    addDomEvent(doc, \"pointercancel\", onPointerUp, false),\n    addDomEvent(doc, \"contextmenu\", onPointerUp, false),\n    disableTextSelection({ doc }),\n  ]\n\n  return () => {\n    cleanups.forEach((cleanup) => cleanup())\n    history.length = 0\n  }\n}\n\nfunction lastDevicePoint(history: TimestampedPoint[]): TimestampedPoint {\n  return history[history.length - 1]\n}\n\nfunction ms(seconds: number): number {\n  return seconds * 1000\n}\n\nfunction sec(milliseconds: number): number {\n  return milliseconds / 1000\n}\n\nfunction getVelocity(history: TimestampedPoint[], timeDelta: number): Point {\n  if (history.length < 2) return { x: 0, y: 0 }\n\n  let i = history.length - 1\n  let timestampedPoint: TimestampedPoint | null = null\n  const lastPoint = lastDevicePoint(history)\n\n  while (i >= 0) {\n    timestampedPoint = history[i]\n    if (lastPoint.timestamp - timestampedPoint.timestamp > ms(timeDelta)) {\n      break\n    }\n    i--\n  }\n\n  if (!timestampedPoint) return { x: 0, y: 0 }\n\n  const time = sec(lastPoint.timestamp - timestampedPoint.timestamp)\n  if (time === 0) return { x: 0, y: 0 }\n\n  const currentVelocity = {\n    x: (lastPoint.x - timestampedPoint.x) / time,\n    y: (lastPoint.y - timestampedPoint.y) / time,\n  }\n\n  if (currentVelocity.x === Infinity) currentVelocity.x = 0\n  if (currentVelocity.y === Infinity) currentVelocity.y = 0\n\n  return {\n    x: Math.abs(currentVelocity.x),\n    y: Math.abs(currentVelocity.y),\n  }\n}\n","import { contains, getDocument, getEventTarget, getWindow } from \"@zag-js/dom-query\"\nimport { addDomEvent } from \"./add-dom-event\"\nimport { getEventPoint } from \"./get-event-point\"\nimport { noop, pipe } from \"./pipe\"\n\ninterface Point {\n  x: number\n  y: number\n}\n\ninterface TapDetails {\n  /**\n   * The current position of the pointer.\n   */\n  point: Point\n  /**\n   * The event that triggered the move.\n   */\n  event: PointerEvent\n}\n\nexport interface TrackPressOptions {\n  /**\n   * The element that will be used to track the pointer events.\n   */\n  pointerNode: Element | null\n  /**\n   * The element that will be used to track the keyboard focus events.\n   */\n  keyboardNode?: Element | null\n  /**\n   * A function that determines if the key is valid for the press event.\n   */\n  isValidKey?(event: KeyboardEvent): boolean\n  /**\n   * A function that will be called when the pointer is pressed.\n   */\n  onPress?(details: TapDetails): void\n  /**\n   * A function that will be called when the pointer is pressed down.\n   */\n  onPressStart?(details: TapDetails): void\n  /**\n   * A function that will be called when the pointer is pressed up or cancelled.\n   */\n  onPressEnd?(details: TapDetails): void\n}\n\nexport function trackPress(options: TrackPressOptions) {\n  const {\n    pointerNode,\n    keyboardNode = pointerNode,\n    onPress,\n    onPressStart,\n    onPressEnd,\n    isValidKey = (e) => e.key === \"Enter\",\n  } = options\n\n  if (!pointerNode) return noop\n\n  const win = getWindow(pointerNode)\n  const doc = getDocument(pointerNode)\n\n  let removeStartListeners: VoidFunction = noop\n  let removeEndListeners: VoidFunction = noop\n  let removeAccessibleListeners: VoidFunction = noop\n\n  const getInfo = (event: PointerEvent): TapDetails => ({\n    point: getEventPoint(event),\n    event,\n  })\n\n  function startPress(event: PointerEvent) {\n    onPressStart?.(getInfo(event))\n  }\n\n  function cancelPress(event: PointerEvent) {\n    onPressEnd?.(getInfo(event))\n  }\n\n  const startPointerPress = (startEvent: PointerEvent) => {\n    removeEndListeners()\n\n    const endPointerPress = (endEvent: PointerEvent) => {\n      const target = getEventTarget<Element>(endEvent)\n      if (contains(pointerNode, target)) {\n        onPress?.(getInfo(endEvent))\n      } else {\n        onPressEnd?.(getInfo(endEvent))\n      }\n    }\n\n    const removePointerUpListener = addDomEvent(win, \"pointerup\", endPointerPress, { passive: !onPress })\n    const removePointerCancelListener = addDomEvent(win, \"pointercancel\", cancelPress, { passive: !onPressEnd })\n\n    removeEndListeners = pipe(removePointerUpListener, removePointerCancelListener)\n\n    if (doc.activeElement === keyboardNode && startEvent.pointerType === \"mouse\") {\n      startEvent.preventDefault()\n    }\n\n    startPress(startEvent)\n  }\n\n  const removePointerListener = addDomEvent(pointerNode, \"pointerdown\", startPointerPress, { passive: !onPressStart })\n  const removeFocusListener = addDomEvent(keyboardNode, \"focus\", startAccessiblePress)\n\n  removeStartListeners = pipe(removePointerListener, removeFocusListener)\n\n  function startAccessiblePress() {\n    const handleKeydown = (keydownEvent: KeyboardEvent) => {\n      if (!isValidKey(keydownEvent)) return\n\n      const handleKeyup = (keyupEvent: KeyboardEvent) => {\n        if (!isValidKey(keyupEvent)) return\n        const evt = new win.PointerEvent(\"pointerup\")\n        const info = getInfo(evt)\n        onPress?.(info)\n        onPressEnd?.(info)\n      }\n\n      removeEndListeners()\n      removeEndListeners = addDomEvent(keyboardNode, \"keyup\", handleKeyup)\n\n      const evt = new win.PointerEvent(\"pointerdown\")\n      startPress(evt)\n    }\n\n    const handleBlur = () => {\n      const evt = new win.PointerEvent(\"pointercancel\")\n      cancelPress(evt)\n    }\n\n    const removeKeydownListener = addDomEvent(keyboardNode, \"keydown\", handleKeydown)\n    const removeBlurListener = addDomEvent(keyboardNode, \"blur\", handleBlur)\n\n    removeAccessibleListeners = pipe(removeKeydownListener, removeBlurListener)\n  }\n\n  return function () {\n    removeStartListeners()\n    removeEndListeners()\n    removeAccessibleListeners()\n  }\n}\n","import { addDomEvent } from \"./add-dom-event\"\n\nexport interface ViewportSize {\n  width: number\n  height: number\n}\n\nexport function trackVisualViewport(doc: Document, fn: (data: ViewportSize) => void) {\n  const win = doc?.defaultView || window\n\n  const onResize = () => {\n    fn?.(getViewportSize(win))\n  }\n\n  onResize()\n\n  return addDomEvent(win.visualViewport ?? win, \"resize\", onResize)\n}\n\nfunction getViewportSize(win: Window): ViewportSize {\n  return {\n    width: win.visualViewport?.width || win.innerWidth,\n    height: win.visualViewport?.height || win.innerHeight,\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"// src/attrs.ts\nvar dataAttr = guard => guard ? \"\" : void 0;\nvar ariaAttr = guard => guard ? \"true\" : void 0;\n\n// src/constants.ts\nvar MAX_Z_INDEX = 2147483647;\n\n// src/is.ts\nvar isHTMLElement = v => typeof v === \"object\" && v?.nodeType === Node.ELEMENT_NODE && typeof v?.nodeName === \"string\";\nvar isDocument = el => el.nodeType === Node.DOCUMENT_NODE;\nvar isWindow = el => el != null && el === el.window;\nvar isVisualViewport = el => el != null && el.constructor.name === \"VisualViewport\";\nvar getNodeName = node => {\n  if (isHTMLElement(node)) return node.localName || \"\";\n  return \"#document\";\n};\nfunction isRootElement(node) {\n  return [\"html\", \"body\", \"#document\"].includes(getNodeName(node));\n}\nvar isNode = el => el.nodeType !== void 0;\nvar isShadowRoot = el => el && isNode(el) && el.nodeType === Node.DOCUMENT_FRAGMENT_NODE && \"host\" in el;\n\n// src/contains.ts\nfunction contains(parent, child) {\n  if (!parent || !child) return false;\n  if (!isHTMLElement(parent) || !isHTMLElement(child)) return false;\n  return parent === child || parent.contains(child);\n}\n\n// src/env.ts\nfunction getDocument(el) {\n  if (isDocument(el)) return el;\n  if (isWindow(el)) return el.document;\n  return el?.ownerDocument ?? document;\n}\nfunction getDocumentElement(el) {\n  return getDocument(el).documentElement;\n}\nfunction getWindow(el) {\n  if (isShadowRoot(el)) return getWindow(el.host);\n  if (isDocument(el)) return el.defaultView ?? window;\n  if (isHTMLElement(el)) return el.ownerDocument?.defaultView ?? window;\n  return window;\n}\nfunction getActiveElement(el) {\n  const doc = getDocument(el);\n  let activeElement = doc.activeElement;\n  while (activeElement?.shadowRoot) {\n    const el2 = activeElement.shadowRoot.activeElement;\n    if (el2 === activeElement) break;else activeElement = el2;\n  }\n  return activeElement;\n}\n\n// src/data-url.ts\nfunction getDataUrl(svg, opts) {\n  const {\n    type,\n    quality = 0.92\n  } = opts;\n  if (!svg) throw new Error(\"[get-data-url]: could not find the svg element\");\n  const win = getWindow(svg);\n  const doc = win.document;\n  const serializer = new win.XMLSerializer();\n  const source = '<?xml version=\"1.0\" standalone=\"no\"?>\\r\\n' + serializer.serializeToString(svg);\n  const svgString = \"data:image/svg+xml;charset=utf-8,\" + encodeURIComponent(source);\n  if (type === \"image/svg+xml\") {\n    return Promise.resolve(svgString);\n  }\n  const svgBounds = svg.getBoundingClientRect();\n  const dpr = win.devicePixelRatio || 1;\n  const canvas = doc.createElement(\"canvas\");\n  const image = new win.Image();\n  image.src = svgString;\n  canvas.width = svgBounds.width * dpr;\n  canvas.height = svgBounds.height * dpr;\n  const context = canvas.getContext(\"2d\");\n  context.scale(dpr, dpr);\n  return new Promise(resolve => {\n    image.onload = () => {\n      context.drawImage(image, 0, 0);\n      resolve(canvas.toDataURL(type, quality));\n    };\n  });\n}\n\n// src/platform.ts\nvar isDom = () => typeof document !== \"undefined\";\nfunction getPlatform() {\n  const agent = navigator.userAgentData;\n  return agent?.platform ?? navigator.platform;\n}\nvar pt = v => isDom() && v.test(getPlatform());\nvar ua = v => isDom() && v.test(navigator.userAgent);\nvar vn = v => isDom() && v.test(navigator.vendor);\nvar isTouchDevice = () => isDom() && !!navigator.maxTouchPoints;\nvar isMac = () => pt(/^Mac/);\nvar isSafari = () => isApple() && vn(/apple/i);\nvar isFirefox = () => ua(/firefox\\//i);\nvar isApple = () => pt(/mac|iphone|ipad|ipod/i);\nvar isIos = () => pt(/iP(hone|ad|od)|iOS/);\nvar isWebKit = () => ua(/AppleWebKit/);\nvar isModKey = event => isApple() ? event.metaKey : event.ctrlKey;\n\n// src/event.ts\nfunction getBeforeInputValue(event) {\n  const {\n    selectionStart,\n    selectionEnd,\n    value\n  } = event.currentTarget;\n  return value.slice(0, selectionStart) + event.data + value.slice(selectionEnd);\n}\nfunction getComposedPath(event) {\n  return event.composedPath?.() ?? event.nativeEvent?.composedPath?.();\n}\nfunction getEventTarget(event) {\n  const composedPath = getComposedPath(event);\n  return composedPath?.[0] ?? event.target;\n}\nvar isSelfTarget = event => {\n  return contains(event.currentTarget, getEventTarget(event));\n};\nfunction isOpeningInNewTab(event) {\n  const element = event.currentTarget;\n  if (!element) return false;\n  const isAppleDevice = isApple();\n  if (isAppleDevice && !event.metaKey) return false;\n  if (!isAppleDevice && !event.ctrlKey) return false;\n  const localName = element.localName;\n  if (localName === \"a\") return true;\n  if (localName === \"button\" && element.type === \"submit\") return true;\n  if (localName === \"input\" && element.type === \"submit\") return true;\n  return false;\n}\nfunction isDownloadingEvent(event) {\n  const element = event.currentTarget;\n  if (!element) return false;\n  const localName = element.localName;\n  if (!event.altKey) return false;\n  if (localName === \"a\") return true;\n  if (localName === \"button\" && element.type === \"submit\") return true;\n  if (localName === \"input\" && element.type === \"submit\") return true;\n  return false;\n}\nfunction isComposingEvent(event) {\n  return event.nativeEvent?.isComposing ?? event.isComposing;\n}\n\n// src/get-by-id.ts\nvar defaultItemToId = v => v.id;\nfunction itemById(v, id, itemToId = defaultItemToId) {\n  return v.find(item => itemToId(item) === id);\n}\nfunction indexOfId(v, id, itemToId = defaultItemToId) {\n  const item = itemById(v, id, itemToId);\n  return item ? v.indexOf(item) : -1;\n}\nfunction nextById(v, id, loop = true) {\n  let idx = indexOfId(v, id);\n  idx = loop ? (idx + 1) % v.length : Math.min(idx + 1, v.length - 1);\n  return v[idx];\n}\nfunction prevById(v, id, loop = true) {\n  let idx = indexOfId(v, id);\n  if (idx === -1) return loop ? v[v.length - 1] : null;\n  idx = loop ? (idx - 1 + v.length) % v.length : Math.max(0, idx - 1);\n  return v[idx];\n}\n\n// src/sanitize.ts\nvar sanitize = str => str.split(\"\").map(char => {\n  const code = char.charCodeAt(0);\n  if (code > 0 && code < 128) return char;\n  if (code >= 128 && code <= 255) return `/x${code.toString(16)}`.replace(\"/\", \"\\\\\");\n  return \"\";\n}).join(\"\").trim();\n\n// src/get-by-text.ts\nvar getValueText = item => sanitize(item.dataset.valuetext ?? item.textContent ?? \"\");\nvar match = (valueText, query2) => valueText.trim().toLowerCase().startsWith(query2.toLowerCase());\nvar wrap = (v, idx) => {\n  return v.map((_, index) => v[(Math.max(idx, 0) + index) % v.length]);\n};\nfunction getByText(v, text, currentId, itemToId = defaultItemToId) {\n  const index = currentId ? indexOfId(v, currentId, itemToId) : -1;\n  let items = currentId ? wrap(v, index) : v;\n  const isSingleKey = text.length === 1;\n  if (isSingleKey) {\n    items = items.filter(item => itemToId(item) !== currentId);\n  }\n  return items.find(item => match(getValueText(item), text));\n}\n\n// src/get-by-typeahead.ts\nfunction getByTypeaheadImpl(_items, options) {\n  const {\n    state,\n    activeId,\n    key,\n    timeout = 350,\n    itemToId\n  } = options;\n  const search = state.keysSoFar + key;\n  const isRepeated = search.length > 1 && Array.from(search).every(char => char === search[0]);\n  const query2 = isRepeated ? search[0] : search;\n  let items = _items.slice();\n  const next = getByText(items, query2, activeId, itemToId);\n  function cleanup() {\n    clearTimeout(state.timer);\n    state.timer = -1;\n  }\n  function update(value) {\n    state.keysSoFar = value;\n    cleanup();\n    if (value !== \"\") {\n      state.timer = +setTimeout(() => {\n        update(\"\");\n        cleanup();\n      }, timeout);\n    }\n  }\n  update(search);\n  return next;\n}\nvar getByTypeahead = /* @__PURE__ */Object.assign(getByTypeaheadImpl, {\n  defaultOptions: {\n    keysSoFar: \"\",\n    timer: -1\n  },\n  isValidEvent: isValidTypeaheadEvent\n});\nfunction isValidTypeaheadEvent(event) {\n  return event.key.length === 1 && !event.ctrlKey && !event.metaKey;\n}\n\n// src/get-computed-style.ts\nvar styleCache = /* @__PURE__ */new WeakMap();\nfunction getComputedStyle(el) {\n  if (!styleCache.has(el)) {\n    styleCache.set(el, getWindow(el).getComputedStyle(el));\n  }\n  return styleCache.get(el);\n}\n\n// src/get-parent-node.ts\nfunction getParentNode(node) {\n  if (getNodeName(node) === \"html\") {\n    return node;\n  }\n  const result =\n  // Step into the shadow DOM of the parent of a slotted node.\n  node.assignedSlot ||\n  // DOM Element detected.\n  node.parentNode ||\n  // ShadowRoot detected.\n  isShadowRoot(node) && node.host ||\n  // Fallback.\n  getDocumentElement(node);\n  return isShadowRoot(result) ? result.host : result;\n}\n\n// src/get-scroll-position.ts\nfunction getScrollPosition(element) {\n  if (isHTMLElement(element)) {\n    return {\n      scrollLeft: element.scrollLeft,\n      scrollTop: element.scrollTop\n    };\n  }\n  return {\n    scrollLeft: element.scrollX,\n    scrollTop: element.scrollY\n  };\n}\n\n// src/tabbable.ts\nvar isHTMLElement2 = element => typeof element === \"object\" && element !== null && element.nodeType === 1;\nvar isFrame = element => isHTMLElement2(element) && element.tagName === \"IFRAME\";\nfunction isVisible(el) {\n  if (!isHTMLElement2(el)) return false;\n  return el.offsetWidth > 0 || el.offsetHeight > 0 || el.getClientRects().length > 0;\n}\nfunction hasNegativeTabIndex(element) {\n  const tabIndex = parseInt(element.getAttribute(\"tabindex\") || \"0\", 10);\n  return tabIndex < 0;\n}\nvar focusableSelector = \"input:not([type='hidden']):not([disabled]), select:not([disabled]), textarea:not([disabled]), a[href], button:not([disabled]), [tabindex], iframe, object, embed, area[href], audio[controls], video[controls], [contenteditable]:not([contenteditable='false']), details > summary:first-of-type\";\nvar getFocusables = (container, includeContainer = false) => {\n  if (!container) return [];\n  const elements = Array.from(container.querySelectorAll(focusableSelector));\n  const include = includeContainer == true || includeContainer == \"if-empty\" && elements.length === 0;\n  if (include && isHTMLElement2(container) && isFocusable(container)) {\n    elements.unshift(container);\n  }\n  const focusableElements = elements.filter(isFocusable);\n  focusableElements.forEach((element, i) => {\n    if (isFrame(element) && element.contentDocument) {\n      const frameBody = element.contentDocument.body;\n      focusableElements.splice(i, 1, ...getFocusables(frameBody));\n    }\n  });\n  return focusableElements;\n};\nfunction isFocusable(element) {\n  if (!element || element.closest(\"[inert]\")) return false;\n  return element.matches(focusableSelector) && isVisible(element);\n}\nfunction getFirstFocusable(container, includeContainer) {\n  const [first] = getFocusables(container, includeContainer);\n  return first || null;\n}\nfunction getTabbables(container, includeContainer) {\n  if (!container) return [];\n  const elements = Array.from(container.querySelectorAll(focusableSelector));\n  const tabbableElements = elements.filter(isTabbable);\n  if (includeContainer && isTabbable(container)) {\n    tabbableElements.unshift(container);\n  }\n  tabbableElements.forEach((element, i) => {\n    if (isFrame(element) && element.contentDocument) {\n      const frameBody = element.contentDocument.body;\n      const allFrameTabbable = getTabbables(frameBody);\n      tabbableElements.splice(i, 1, ...allFrameTabbable);\n    }\n  });\n  if (!tabbableElements.length && includeContainer) {\n    return elements;\n  }\n  return tabbableElements;\n}\nfunction isTabbable(el) {\n  if (el != null && el.tabIndex > 0) return true;\n  return isFocusable(el) && !hasNegativeTabIndex(el);\n}\nfunction getFirstTabbable(container, includeContainer) {\n  const [first] = getTabbables(container, includeContainer);\n  return first || null;\n}\nfunction getLastTabbable(container, includeContainer) {\n  const elements = getTabbables(container, includeContainer);\n  return elements[elements.length - 1] || null;\n}\nfunction getTabbableEdges(container, includeContainer) {\n  const elements = getTabbables(container, includeContainer);\n  const first = elements[0] || null;\n  const last = elements[elements.length - 1] || null;\n  return [first, last];\n}\nfunction getNextTabbable(container, current) {\n  const tabbables = getTabbables(container);\n  const doc = container?.ownerDocument || document;\n  const currentElement = current ?? doc.activeElement;\n  if (!currentElement) return null;\n  const index = tabbables.indexOf(currentElement);\n  return tabbables[index + 1] || null;\n}\n\n// src/initial-focus.ts\nfunction getInitialFocus(options) {\n  const {\n    root,\n    getInitialEl,\n    filter,\n    enabled = true\n  } = options;\n  if (!enabled) return;\n  let node = null;\n  node || (node = typeof getInitialEl === \"function\" ? getInitialEl() : getInitialEl);\n  node || (node = root?.querySelector(\"[data-autofocus],[autofocus]\"));\n  if (!node) {\n    const tabbables = getTabbables(root);\n    node = filter ? tabbables.filter(filter)[0] : tabbables[0];\n  }\n  return node || root || void 0;\n}\nfunction isValidTabEvent(event) {\n  const container = event.currentTarget;\n  if (!container) return false;\n  const [firstTabbable, lastTabbable] = getTabbableEdges(container);\n  const doc = container.ownerDocument || document;\n  if (doc.activeElement === firstTabbable && event.shiftKey) return false;\n  if (doc.activeElement === lastTabbable && !event.shiftKey) return false;\n  if (!firstTabbable && !lastTabbable) return false;\n  return true;\n}\n\n// src/is-editable-element.ts\nfunction isEditableElement(el) {\n  if (el == null || !isHTMLElement(el)) {\n    return false;\n  }\n  try {\n    const win = getWindow(el);\n    return el instanceof win.HTMLInputElement && el.selectionStart != null || /(textarea|select)/.test(el.localName) || el.isContentEditable;\n  } catch {\n    return false;\n  }\n}\n\n// src/is-hidden-element.ts\nfunction isHiddenElement(node) {\n  if (node.parentElement && isHiddenElement(node.parentElement)) return true;\n  return node.hidden;\n}\n\n// src/is-overflow-element.ts\nvar OVERFLOW_RE = /auto|scroll|overlay|hidden|clip/;\nfunction isOverflowElement(el) {\n  const win = getWindow(el);\n  const {\n    overflow,\n    overflowX,\n    overflowY,\n    display\n  } = win.getComputedStyle(el);\n  return OVERFLOW_RE.test(overflow + overflowY + overflowX) && ![\"inline\", \"contents\"].includes(display);\n}\n\n// src/raf.ts\nfunction nextTick(fn) {\n  const set2 = /* @__PURE__ */new Set();\n  function raf2(fn2) {\n    const id = globalThis.requestAnimationFrame(fn2);\n    set2.add(() => globalThis.cancelAnimationFrame(id));\n  }\n  raf2(() => raf2(fn));\n  return function cleanup() {\n    set2.forEach(fn2 => fn2());\n  };\n}\nfunction raf(fn) {\n  const id = globalThis.requestAnimationFrame(fn);\n  return () => {\n    globalThis.cancelAnimationFrame(id);\n  };\n}\n\n// src/observe-attributes.ts\nfunction observeAttributesImpl(node, options) {\n  if (!node) return;\n  const {\n    attributes,\n    callback: fn\n  } = options;\n  const win = node.ownerDocument.defaultView || window;\n  const obs = new win.MutationObserver(changes => {\n    for (const change of changes) {\n      if (change.type === \"attributes\" && change.attributeName && attributes.includes(change.attributeName)) {\n        fn(change);\n      }\n    }\n  });\n  obs.observe(node, {\n    attributes: true,\n    attributeFilter: attributes\n  });\n  return () => obs.disconnect();\n}\nfunction observeAttributes(nodeOrFn, options) {\n  const {\n    defer\n  } = options;\n  const func = defer ? raf : v => v();\n  const cleanups2 = [];\n  cleanups2.push(func(() => {\n    const node = typeof nodeOrFn === \"function\" ? nodeOrFn() : nodeOrFn;\n    cleanups2.push(observeAttributesImpl(node, options));\n  }));\n  return () => {\n    cleanups2.forEach(fn => fn?.());\n  };\n}\n\n// src/observe-children.ts\nfunction observeChildrenImpl(node, options) {\n  const {\n    callback: fn\n  } = options;\n  if (!node) return;\n  const win = node.ownerDocument.defaultView || window;\n  const obs = new win.MutationObserver(fn);\n  obs.observe(node, {\n    childList: true,\n    subtree: true\n  });\n  return () => obs.disconnect();\n}\nfunction observeChildren(nodeOrFn, options) {\n  const {\n    defer\n  } = options;\n  const func = defer ? raf : v => v();\n  const cleanups2 = [];\n  cleanups2.push(func(() => {\n    const node = typeof nodeOrFn === \"function\" ? nodeOrFn() : nodeOrFn;\n    cleanups2.push(observeChildrenImpl(node, options));\n  }));\n  return () => {\n    cleanups2.forEach(fn => fn?.());\n  };\n}\n\n// src/overflow.ts\nfunction getNearestOverflowAncestor(el) {\n  const parentNode = getParentNode(el);\n  if (isRootElement(parentNode)) {\n    return getDocument(parentNode).body;\n  }\n  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {\n    return parentNode;\n  }\n  return getNearestOverflowAncestor(parentNode);\n}\nfunction getOverflowAncestors(el, list = []) {\n  const scrollableAncestor = getNearestOverflowAncestor(el);\n  const isBody = scrollableAncestor === el.ownerDocument.body;\n  const win = getWindow(scrollableAncestor);\n  if (isBody) {\n    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : []);\n  }\n  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, []));\n}\nvar getRect = el => {\n  if (isHTMLElement(el)) {\n    return el.getBoundingClientRect();\n  }\n  if (isVisualViewport(el)) {\n    return {\n      top: 0,\n      left: 0,\n      bottom: el.height,\n      right: el.width\n    };\n  }\n  return {\n    top: 0,\n    left: 0,\n    bottom: el.innerHeight,\n    right: el.innerWidth\n  };\n};\nfunction isInView(el, ancestor) {\n  if (!isHTMLElement(el)) return true;\n  const ancestorRect = getRect(ancestor);\n  const elRect = el.getBoundingClientRect();\n  return elRect.top >= ancestorRect.top && elRect.left >= ancestorRect.left && elRect.bottom <= ancestorRect.bottom && elRect.right <= ancestorRect.right;\n}\n\n// src/proxy-tab-focus.ts\nfunction proxyTabFocusImpl(container, options = {}) {\n  const {\n    triggerElement,\n    onFocus\n  } = options;\n  const doc = container?.ownerDocument || document;\n  const body = doc.body;\n  function onKeyDown(event) {\n    if (event.key !== \"Tab\") return;\n    let elementToFocus = null;\n    const [firstTabbable, lastTabbable] = getTabbableEdges(container, true);\n    const noTabbableElements = !firstTabbable && !lastTabbable;\n    if (event.shiftKey && (doc.activeElement === firstTabbable || noTabbableElements)) {\n      elementToFocus = triggerElement;\n    } else if (!event.shiftKey && doc.activeElement === triggerElement) {\n      elementToFocus = firstTabbable;\n    } else if (!event.shiftKey && (doc.activeElement === lastTabbable || noTabbableElements)) {\n      elementToFocus = getNextTabbable(body, triggerElement);\n    }\n    if (!elementToFocus) return;\n    event.preventDefault();\n    if (typeof onFocus === \"function\") {\n      onFocus(elementToFocus);\n    } else {\n      elementToFocus.focus();\n    }\n  }\n  doc?.addEventListener(\"keydown\", onKeyDown, true);\n  return () => {\n    doc?.removeEventListener(\"keydown\", onKeyDown, true);\n  };\n}\nfunction proxyTabFocus(container, options) {\n  const {\n    defer,\n    triggerElement,\n    ...restOptions\n  } = options;\n  const func = defer ? raf : v => v();\n  const cleanups2 = [];\n  cleanups2.push(func(() => {\n    const node = typeof container === \"function\" ? container() : container;\n    const trigger = typeof triggerElement === \"function\" ? triggerElement() : triggerElement;\n    cleanups2.push(proxyTabFocusImpl(node, {\n      triggerElement: trigger,\n      ...restOptions\n    }));\n  }));\n  return () => {\n    cleanups2.forEach(fn => fn?.());\n  };\n}\n\n// src/query.ts\nfunction queryAll(root, selector) {\n  return Array.from(root?.querySelectorAll(selector) ?? []);\n}\nfunction query(root, selector) {\n  return root?.querySelector(selector) ?? null;\n}\n\n// src/scope.ts\nfunction createScope(methods) {\n  const dom = {\n    getRootNode: ctx => ctx.getRootNode?.() ?? document,\n    getDoc: ctx => getDocument(dom.getRootNode(ctx)),\n    getWin: ctx => dom.getDoc(ctx).defaultView ?? window,\n    getActiveElement: ctx => dom.getRootNode(ctx).activeElement,\n    isActiveElement: (ctx, elem) => elem === dom.getActiveElement(ctx),\n    getById: (ctx, id) => dom.getRootNode(ctx).getElementById(id),\n    setValue: (elem, value) => {\n      if (elem == null || value == null) return;\n      const valueAsString = value.toString();\n      if (elem.value === valueAsString) return;\n      elem.value = value.toString();\n    }\n  };\n  return {\n    ...dom,\n    ...methods\n  };\n}\n\n// src/scroll-into-view.ts\nfunction isScrollable(el) {\n  return el.scrollHeight > el.clientHeight || el.scrollWidth > el.clientWidth;\n}\nfunction scrollIntoView(el, options) {\n  const {\n    rootEl,\n    ...scrollOptions\n  } = options || {};\n  if (!el || !rootEl) {\n    return;\n  }\n  if (!isOverflowElement(rootEl) || !isScrollable(rootEl)) {\n    return;\n  }\n  el.scrollIntoView(scrollOptions);\n}\n\n// src/set.ts\nvar cleanups = /* @__PURE__ */new WeakMap();\nfunction set(element, key, setup) {\n  if (!cleanups.has(element)) {\n    cleanups.set(element, /* @__PURE__ */new Map());\n  }\n  const elementCleanups = cleanups.get(element);\n  const prevCleanup = elementCleanups.get(key);\n  if (!prevCleanup) {\n    elementCleanups.set(key, setup());\n    return () => {\n      elementCleanups.get(key)?.();\n      elementCleanups.delete(key);\n    };\n  }\n  const cleanup = setup();\n  const nextCleanup = () => {\n    cleanup();\n    prevCleanup();\n    elementCleanups.delete(key);\n  };\n  elementCleanups.set(key, nextCleanup);\n  return () => {\n    const isCurrent = elementCleanups.get(key) === nextCleanup;\n    if (!isCurrent) return;\n    cleanup();\n    elementCleanups.set(key, prevCleanup);\n  };\n}\nfunction setAttribute(element, attr, value) {\n  const setup = () => {\n    const previousValue = element.getAttribute(attr);\n    element.setAttribute(attr, value);\n    return () => {\n      if (previousValue == null) {\n        element.removeAttribute(attr);\n      } else {\n        element.setAttribute(attr, previousValue);\n      }\n    };\n  };\n  return set(element, attr, setup);\n}\nfunction setProperty(element, property, value) {\n  const setup = () => {\n    const exists = property in element;\n    const previousValue = element[property];\n    element[property] = value;\n    return () => {\n      if (!exists) {\n        delete element[property];\n      } else {\n        element[property] = previousValue;\n      }\n    };\n  };\n  return set(element, property, setup);\n}\nfunction setStyle(element, style) {\n  if (!element) return () => {};\n  const setup = () => {\n    const prevStyle = element.style.cssText;\n    Object.assign(element.style, style);\n    return () => {\n      element.style.cssText = prevStyle;\n    };\n  };\n  return set(element, \"style\", setup);\n}\n\n// src/visually-hidden.ts\nvar visuallyHiddenStyle = {\n  border: \"0\",\n  clip: \"rect(0 0 0 0)\",\n  height: \"1px\",\n  margin: \"-1px\",\n  overflow: \"hidden\",\n  padding: \"0\",\n  position: \"absolute\",\n  width: \"1px\",\n  whiteSpace: \"nowrap\",\n  wordWrap: \"normal\"\n};\n\n// src/wait-for.ts\nvar fps = 1e3 / 60;\nfunction waitForElement(query2, cb) {\n  const el = query2();\n  if (isHTMLElement(el) && el.isConnected) {\n    cb(el);\n    return () => void 0;\n  } else {\n    const timerId = setInterval(() => {\n      const el2 = query2();\n      if (isHTMLElement(el2) && el2.isConnected) {\n        cb(el2);\n        clearInterval(timerId);\n      }\n    }, fps);\n    return () => clearInterval(timerId);\n  }\n}\nfunction waitForElements(queries, cb) {\n  const cleanups2 = [];\n  queries?.forEach(query2 => {\n    const clean = waitForElement(query2, cb);\n    cleanups2.push(clean);\n  });\n  return () => {\n    cleanups2.forEach(fn => fn());\n  };\n}\nexport { MAX_Z_INDEX, ariaAttr, contains, createScope, dataAttr, defaultItemToId, getActiveElement, getBeforeInputValue, getByText, getByTypeahead, getComputedStyle, getDataUrl, getDocument, getDocumentElement, getEventTarget, getFirstFocusable, getFirstTabbable, getFocusables, getInitialFocus, getLastTabbable, getNearestOverflowAncestor, getNextTabbable, getNodeName, getOverflowAncestors, getParentNode, getPlatform, getScrollPosition, getTabbableEdges, getTabbables, getWindow, indexOfId, isApple, isComposingEvent, isDocument, isDom, isDownloadingEvent, isEditableElement, isFirefox, isFocusable, isHTMLElement, isHiddenElement, isInView, isIos, isMac, isModKey, isNode, isOpeningInNewTab, isOverflowElement, isRootElement, isSafari, isSelfTarget, isShadowRoot, isTabbable, isTouchDevice, isValidTabEvent, isVisualViewport, isWebKit, isWindow, itemById, nextById, nextTick, observeAttributes, observeChildren, prevById, proxyTabFocus, query, queryAll, raf, scrollIntoView, set, setAttribute, setProperty, setStyle, visuallyHiddenStyle, waitForElement, waitForElements };","map":{"version":3,"names":["dataAttr","guard","ariaAttr","MAX_Z_INDEX","isHTMLElement","v","nodeType","Node","ELEMENT_NODE","nodeName","isDocument","el","DOCUMENT_NODE","isWindow","window","isVisualViewport","constructor","name","getNodeName","node","localName","isRootElement","includes","isNode","isShadowRoot","DOCUMENT_FRAGMENT_NODE","contains","parent","child","getDocument","document","ownerDocument","getDocumentElement","documentElement","getWindow","host","defaultView","getActiveElement","doc","activeElement","shadowRoot","el2","getDataUrl","svg","opts","type","quality","Error","win","serializer","XMLSerializer","source","serializeToString","svgString","encodeURIComponent","Promise","resolve","svgBounds","getBoundingClientRect","dpr","devicePixelRatio","canvas","createElement","image","Image","src","width","height","context","getContext","scale","onload","drawImage","toDataURL","isDom","getPlatform","agent","navigator","userAgentData","platform","pt","test","ua","userAgent","vn","vendor","isTouchDevice","maxTouchPoints","isMac","isSafari","isApple","isFirefox","isIos","isWebKit","isModKey","event","metaKey","ctrlKey","getBeforeInputValue","selectionStart","selectionEnd","value","currentTarget","slice","data","getComposedPath","composedPath","nativeEvent","getEventTarget","target","isSelfTarget","isOpeningInNewTab","element","isAppleDevice","isDownloadingEvent","altKey","isComposingEvent","isComposing","defaultItemToId","id","itemById","itemToId","find","item","indexOfId","indexOf","nextById","loop","idx","length","Math","min","prevById","max","sanitize","str","split","map","char","code","charCodeAt","toString","replace","join","trim","getValueText","dataset","valuetext","textContent","match","valueText","query2","toLowerCase","startsWith","wrap","_","index","getByText","text","currentId","items","isSingleKey","filter","getByTypeaheadImpl","_items","options","state","activeId","key","timeout","search","keysSoFar","isRepeated","Array","from","every","next","cleanup","clearTimeout","timer","update","setTimeout","getByTypeahead","Object","assign","defaultOptions","isValidEvent","isValidTypeaheadEvent","styleCache","WeakMap","getComputedStyle","has","set","get","getParentNode","result","assignedSlot","parentNode","getScrollPosition","scrollLeft","scrollTop","scrollX","scrollY","isHTMLElement2","isFrame","tagName","isVisible","offsetWidth","offsetHeight","getClientRects","hasNegativeTabIndex","tabIndex","parseInt","getAttribute","focusableSelector","getFocusables","container","includeContainer","elements","querySelectorAll","include","isFocusable","unshift","focusableElements","forEach","i","contentDocument","frameBody","body","splice","closest","matches","getFirstFocusable","first","getTabbables","tabbableElements","isTabbable","allFrameTabbable","getFirstTabbable","getLastTabbable","getTabbableEdges","last","getNextTabbable","current","tabbables","currentElement","getInitialFocus","root","getInitialEl","enabled","querySelector","isValidTabEvent","firstTabbable","lastTabbable","shiftKey","isEditableElement","HTMLInputElement","isContentEditable","isHiddenElement","parentElement","hidden","OVERFLOW_RE","isOverflowElement","overflow","overflowX","overflowY","display","nextTick","fn","set2","Set","raf2","fn2","globalThis","requestAnimationFrame","add","cancelAnimationFrame","raf","observeAttributesImpl","attributes","callback","obs","MutationObserver","changes","change","attributeName","observe","attributeFilter","disconnect","observeAttributes","nodeOrFn","defer","func","cleanups2","push","observeChildrenImpl","childList","subtree","observeChildren","getNearestOverflowAncestor","getOverflowAncestors","list","scrollableAncestor","isBody","concat","visualViewport","getRect","top","left","bottom","right","innerHeight","innerWidth","isInView","ancestor","ancestorRect","elRect","proxyTabFocusImpl","triggerElement","onFocus","onKeyDown","elementToFocus","noTabbableElements","preventDefault","focus","addEventListener","removeEventListener","proxyTabFocus","restOptions","trigger","queryAll","selector","query","createScope","methods","dom","getRootNode","ctx","getDoc","getWin","isActiveElement","elem","getById","getElementById","setValue","valueAsString","isScrollable","scrollHeight","clientHeight","scrollWidth","clientWidth","scrollIntoView","rootEl","scrollOptions","cleanups","setup","Map","elementCleanups","prevCleanup","delete","nextCleanup","isCurrent","setAttribute","attr","previousValue","removeAttribute","setProperty","property","exists","setStyle","style","prevStyle","cssText","visuallyHiddenStyle","border","clip","margin","padding","position","whiteSpace","wordWrap","fps","waitForElement","cb","isConnected","timerId","setInterval","clearInterval","waitForElements","queries","clean"],"sources":["C:\\Users\\lab_services_student\\Desktop\\PartThree\\frontend\\node_modules\\@zag-js\\switch\\node_modules\\@zag-js\\dom-query\\src\\attrs.ts","C:\\Users\\lab_services_student\\Desktop\\PartThree\\frontend\\node_modules\\@zag-js\\switch\\node_modules\\@zag-js\\dom-query\\src\\constants.ts","C:\\Users\\lab_services_student\\Desktop\\PartThree\\frontend\\node_modules\\@zag-js\\switch\\node_modules\\@zag-js\\dom-query\\src\\is.ts","C:\\Users\\lab_services_student\\Desktop\\PartThree\\frontend\\node_modules\\@zag-js\\switch\\node_modules\\@zag-js\\dom-query\\src\\contains.ts","C:\\Users\\lab_services_student\\Desktop\\PartThree\\frontend\\node_modules\\@zag-js\\switch\\node_modules\\@zag-js\\dom-query\\src\\env.ts","C:\\Users\\lab_services_student\\Desktop\\PartThree\\frontend\\node_modules\\@zag-js\\switch\\node_modules\\@zag-js\\dom-query\\src\\data-url.ts","C:\\Users\\lab_services_student\\Desktop\\PartThree\\frontend\\node_modules\\@zag-js\\switch\\node_modules\\@zag-js\\dom-query\\src\\platform.ts","C:\\Users\\lab_services_student\\Desktop\\PartThree\\frontend\\node_modules\\@zag-js\\switch\\node_modules\\@zag-js\\dom-query\\src\\event.ts","C:\\Users\\lab_services_student\\Desktop\\PartThree\\frontend\\node_modules\\@zag-js\\switch\\node_modules\\@zag-js\\dom-query\\src\\get-by-id.ts","C:\\Users\\lab_services_student\\Desktop\\PartThree\\frontend\\node_modules\\@zag-js\\switch\\node_modules\\@zag-js\\dom-query\\src\\sanitize.ts","C:\\Users\\lab_services_student\\Desktop\\PartThree\\frontend\\node_modules\\@zag-js\\switch\\node_modules\\@zag-js\\dom-query\\src\\get-by-text.ts","C:\\Users\\lab_services_student\\Desktop\\PartThree\\frontend\\node_modules\\@zag-js\\switch\\node_modules\\@zag-js\\dom-query\\src\\get-by-typeahead.ts","C:\\Users\\lab_services_student\\Desktop\\PartThree\\frontend\\node_modules\\@zag-js\\switch\\node_modules\\@zag-js\\dom-query\\src\\get-computed-style.ts","C:\\Users\\lab_services_student\\Desktop\\PartThree\\frontend\\node_modules\\@zag-js\\switch\\node_modules\\@zag-js\\dom-query\\src\\get-parent-node.ts","C:\\Users\\lab_services_student\\Desktop\\PartThree\\frontend\\node_modules\\@zag-js\\switch\\node_modules\\@zag-js\\dom-query\\src\\get-scroll-position.ts","C:\\Users\\lab_services_student\\Desktop\\PartThree\\frontend\\node_modules\\@zag-js\\switch\\node_modules\\@zag-js\\dom-query\\src\\tabbable.ts","C:\\Users\\lab_services_student\\Desktop\\PartThree\\frontend\\node_modules\\@zag-js\\switch\\node_modules\\@zag-js\\dom-query\\src\\initial-focus.ts","C:\\Users\\lab_services_student\\Desktop\\PartThree\\frontend\\node_modules\\@zag-js\\switch\\node_modules\\@zag-js\\dom-query\\src\\is-editable-element.ts","C:\\Users\\lab_services_student\\Desktop\\PartThree\\frontend\\node_modules\\@zag-js\\switch\\node_modules\\@zag-js\\dom-query\\src\\is-hidden-element.ts","C:\\Users\\lab_services_student\\Desktop\\PartThree\\frontend\\node_modules\\@zag-js\\switch\\node_modules\\@zag-js\\dom-query\\src\\is-overflow-element.ts","C:\\Users\\lab_services_student\\Desktop\\PartThree\\frontend\\node_modules\\@zag-js\\switch\\node_modules\\@zag-js\\dom-query\\src\\raf.ts","C:\\Users\\lab_services_student\\Desktop\\PartThree\\frontend\\node_modules\\@zag-js\\switch\\node_modules\\@zag-js\\dom-query\\src\\observe-attributes.ts","C:\\Users\\lab_services_student\\Desktop\\PartThree\\frontend\\node_modules\\@zag-js\\switch\\node_modules\\@zag-js\\dom-query\\src\\observe-children.ts","C:\\Users\\lab_services_student\\Desktop\\PartThree\\frontend\\node_modules\\@zag-js\\switch\\node_modules\\@zag-js\\dom-query\\src\\overflow.ts","C:\\Users\\lab_services_student\\Desktop\\PartThree\\frontend\\node_modules\\@zag-js\\switch\\node_modules\\@zag-js\\dom-query\\src\\proxy-tab-focus.ts","C:\\Users\\lab_services_student\\Desktop\\PartThree\\frontend\\node_modules\\@zag-js\\switch\\node_modules\\@zag-js\\dom-query\\src\\query.ts","C:\\Users\\lab_services_student\\Desktop\\PartThree\\frontend\\node_modules\\@zag-js\\switch\\node_modules\\@zag-js\\dom-query\\src\\scope.ts","C:\\Users\\lab_services_student\\Desktop\\PartThree\\frontend\\node_modules\\@zag-js\\switch\\node_modules\\@zag-js\\dom-query\\src\\scroll-into-view.ts","C:\\Users\\lab_services_student\\Desktop\\PartThree\\frontend\\node_modules\\@zag-js\\switch\\node_modules\\@zag-js\\dom-query\\src\\set.ts","C:\\Users\\lab_services_student\\Desktop\\PartThree\\frontend\\node_modules\\@zag-js\\switch\\node_modules\\@zag-js\\dom-query\\src\\visually-hidden.ts","C:\\Users\\lab_services_student\\Desktop\\PartThree\\frontend\\node_modules\\@zag-js\\switch\\node_modules\\@zag-js\\dom-query\\src\\wait-for.ts"],"sourcesContent":["import type { Booleanish } from \"./types\"\n\nexport const dataAttr = (guard: boolean | undefined) => (guard ? \"\" : undefined) as Booleanish\nexport const ariaAttr = (guard: boolean | undefined) => (guard ? \"true\" : undefined)\n","export const MAX_Z_INDEX = 2147483647\n","export const isHTMLElement = (v: any): v is HTMLElement =>\n  typeof v === \"object\" && v?.nodeType === Node.ELEMENT_NODE && typeof v?.nodeName === \"string\"\n\nexport const isDocument = (el: any): el is Document => el.nodeType === Node.DOCUMENT_NODE\n\nexport const isWindow = (el: any): el is Window => el != null && el === el.window\n\nexport const isVisualViewport = (el: any): el is VisualViewport =>\n  el != null && el.constructor.name === \"VisualViewport\"\n\nexport const getNodeName = (node: Node | Window): string => {\n  if (isHTMLElement(node)) return node.localName || \"\"\n  return \"#document\"\n}\n\nexport function isRootElement(node: Node): boolean {\n  return [\"html\", \"body\", \"#document\"].includes(getNodeName(node))\n}\n\nexport const isNode = (el: any): el is Node => el.nodeType !== undefined\n\nexport const isShadowRoot = (el: any): el is ShadowRoot =>\n  el && isNode(el) && el.nodeType === Node.DOCUMENT_FRAGMENT_NODE && \"host\" in el\n","import { isHTMLElement } from \"./is\"\n\ntype Target = HTMLElement | EventTarget | null | undefined\n\nexport function contains(parent: Target, child: Target) {\n  if (!parent || !child) return false\n  if (!isHTMLElement(parent) || !isHTMLElement(child)) return false\n  return parent === child || parent.contains(child)\n}\n","import { isHTMLElement, isDocument, isShadowRoot, isWindow } from \"./is\"\n\nexport function getDocument(el: Element | Window | Node | Document | null) {\n  if (isDocument(el)) return el\n  if (isWindow(el)) return el.document\n  return el?.ownerDocument ?? document\n}\n\nexport function getDocumentElement(el: Element | Node | Window | Document | null): HTMLElement {\n  return getDocument(el).documentElement\n}\n\nexport function getWindow(el: Node | ShadowRoot | Document | undefined) {\n  if (isShadowRoot(el)) return getWindow(el.host)\n  if (isDocument(el)) return el.defaultView ?? window\n  if (isHTMLElement(el)) return el.ownerDocument?.defaultView ?? window\n  return window\n}\n\nexport function getActiveElement(el: HTMLElement): HTMLElement | null {\n  const doc = getDocument(el)\n  let activeElement = doc.activeElement as HTMLElement | null\n\n  while (activeElement?.shadowRoot) {\n    const el = activeElement.shadowRoot.activeElement as HTMLElement | null\n    if (el === activeElement) break\n    else activeElement = el\n  }\n\n  return activeElement\n}\n","import { getWindow } from \"./env\"\n\nexport type DataUrlType = \"image/png\" | \"image/jpeg\" | \"image/svg+xml\"\n\nexport interface DataUrlOptions {\n  type: DataUrlType\n  quality?: number\n}\n\nexport function getDataUrl(svg: SVGElement | undefined | null, opts: DataUrlOptions): Promise<string> {\n  const { type, quality = 0.92 } = opts\n\n  if (!svg) throw new Error(\"[get-data-url]: could not find the svg element\")\n\n  const win = getWindow(svg)\n  const doc = win.document\n\n  const serializer = new win.XMLSerializer()\n  const source = '<?xml version=\"1.0\" standalone=\"no\"?>\\r\\n' + serializer.serializeToString(svg)\n  const svgString = \"data:image/svg+xml;charset=utf-8,\" + encodeURIComponent(source)\n\n  if (type === \"image/svg+xml\") {\n    return Promise.resolve(svgString)\n  }\n\n  const svgBounds = svg.getBoundingClientRect()\n  const dpr = win.devicePixelRatio || 1\n\n  const canvas = doc.createElement(\"canvas\")\n  const image = new win.Image()\n  image.src = svgString\n\n  canvas.width = svgBounds.width * dpr\n  canvas.height = svgBounds.height * dpr\n\n  const context = canvas.getContext(\"2d\")\n  context!.scale(dpr, dpr)\n\n  return new Promise((resolve) => {\n    image.onload = () => {\n      context!.drawImage(image, 0, 0)\n      resolve(canvas.toDataURL(type, quality))\n    }\n  })\n}\n","export const isDom = () => typeof document !== \"undefined\"\n\nexport function getPlatform() {\n  const agent = (navigator as any).userAgentData\n  return agent?.platform ?? navigator.platform\n}\n\nconst pt = (v: RegExp) => isDom() && v.test(getPlatform())\nconst ua = (v: RegExp) => isDom() && v.test(navigator.userAgent)\nconst vn = (v: RegExp) => isDom() && v.test(navigator.vendor)\n\nexport const isTouchDevice = () => isDom() && !!navigator.maxTouchPoints\nexport const isMac = () => pt(/^Mac/)\nexport const isSafari = () => isApple() && vn(/apple/i)\nexport const isFirefox = () => ua(/firefox\\//i)\nexport const isApple = () => pt(/mac|iphone|ipad|ipod/i)\nexport const isIos = () => pt(/iP(hone|ad|od)|iOS/)\nexport const isWebKit = () => ua(/AppleWebKit/)\n\nexport const isModKey = (event: Pick<KeyboardEvent, \"metaKey\" | \"ctrlKey\">) =>\n  isApple() ? event.metaKey : event.ctrlKey\n","import { contains } from \"./contains\"\nimport { isApple } from \"./platform\"\n\nexport function getBeforeInputValue(event: Pick<InputEvent, \"currentTarget\">) {\n  const { selectionStart, selectionEnd, value } = event.currentTarget as HTMLInputElement\n  return value.slice(0, selectionStart!) + (event as any).data + value.slice(selectionEnd!)\n}\n\nfunction getComposedPath(event: any): EventTarget[] | undefined {\n  return event.composedPath?.() ?? event.nativeEvent?.composedPath?.()\n}\n\nexport function getEventTarget<T extends EventTarget>(\n  event: Partial<Pick<UIEvent, \"target\" | \"composedPath\">>,\n): T | null {\n  const composedPath = getComposedPath(event)\n  return (composedPath?.[0] ?? event.target) as T | null\n}\n\nexport const isSelfTarget = (event: Partial<Pick<UIEvent, \"currentTarget\" | \"target\" | \"composedPath\">>) => {\n  return contains(event.currentTarget as Node, getEventTarget(event))\n}\n\nexport function isOpeningInNewTab(event: Pick<MouseEvent, \"currentTarget\" | \"metaKey\" | \"ctrlKey\">) {\n  const element = event.currentTarget as HTMLAnchorElement | HTMLButtonElement | HTMLInputElement | null\n  if (!element) return false\n\n  const isAppleDevice = isApple()\n  if (isAppleDevice && !event.metaKey) return false\n  if (!isAppleDevice && !event.ctrlKey) return false\n\n  const localName = element.localName\n\n  if (localName === \"a\") return true\n  if (localName === \"button\" && element.type === \"submit\") return true\n  if (localName === \"input\" && element.type === \"submit\") return true\n\n  return false\n}\n\nexport function isDownloadingEvent(event: Pick<MouseEvent, \"altKey\" | \"currentTarget\">) {\n  const element = event.currentTarget as HTMLAnchorElement | HTMLButtonElement | HTMLInputElement | null\n  if (!element) return false\n\n  const localName = element.localName\n  if (!event.altKey) return false\n\n  if (localName === \"a\") return true\n  if (localName === \"button\" && element.type === \"submit\") return true\n  if (localName === \"input\" && element.type === \"submit\") return true\n\n  return false\n}\n\nexport function isComposingEvent(event: any) {\n  return event.nativeEvent?.isComposing ?? event.isComposing\n}\n","export type ItemToId<T> = (v: T) => string\n\nexport const defaultItemToId = <T extends HTMLElement>(v: T) => v.id\n\nexport function itemById<T extends HTMLElement>(v: T[], id: string, itemToId: ItemToId<T> = defaultItemToId) {\n  return v.find((item) => itemToId(item) === id)\n}\n\nexport function indexOfId<T extends HTMLElement>(v: T[], id: string, itemToId: ItemToId<T> = defaultItemToId) {\n  const item = itemById(v, id, itemToId)\n  return item ? v.indexOf(item) : -1\n}\n\nexport function nextById<T extends HTMLElement>(v: T[], id: string, loop = true) {\n  let idx = indexOfId(v, id)\n  idx = loop ? (idx + 1) % v.length : Math.min(idx + 1, v.length - 1)\n  return v[idx]\n}\n\nexport function prevById<T extends HTMLElement>(v: T[], id: string, loop = true) {\n  let idx = indexOfId(v, id)\n  if (idx === -1) return loop ? v[v.length - 1] : null\n  idx = loop ? (idx - 1 + v.length) % v.length : Math.max(0, idx - 1)\n  return v[idx]\n}\n","export const sanitize = (str: string) =>\n  str\n    .split(\"\")\n    .map((char) => {\n      const code = char.charCodeAt(0)\n      if (code > 0 && code < 128) return char\n      if (code >= 128 && code <= 255) return `/x${code.toString(16)}`.replace(\"/\", \"\\\\\")\n      return \"\"\n    })\n    .join(\"\")\n    .trim()\n","import { defaultItemToId, indexOfId, type ItemToId } from \"./get-by-id\"\nimport { sanitize } from \"./sanitize\"\n\nconst getValueText = <T extends HTMLElement>(item: T) => sanitize(item.dataset.valuetext ?? item.textContent ?? \"\")\n\nconst match = (valueText: string, query: string) => valueText.trim().toLowerCase().startsWith(query.toLowerCase())\n\nconst wrap = <T>(v: T[], idx: number) => {\n  return v.map((_, index) => v[(Math.max(idx, 0) + index) % v.length])\n}\n\nexport function getByText<T extends HTMLElement>(\n  v: T[],\n  text: string,\n  currentId?: string | null,\n  itemToId: ItemToId<T> = defaultItemToId,\n) {\n  const index = currentId ? indexOfId(v, currentId, itemToId) : -1\n  let items = currentId ? wrap(v, index) : v\n\n  const isSingleKey = text.length === 1\n\n  if (isSingleKey) {\n    items = items.filter((item) => itemToId(item) !== currentId)\n  }\n\n  return items.find((item) => match(getValueText(item), text))\n}\n","import { getByText } from \"./get-by-text\"\nimport type { ItemToId } from \"./get-by-id\"\n\nexport interface TypeaheadState {\n  keysSoFar: string\n  timer: number\n}\n\nexport interface TypeaheadOptions {\n  state: TypeaheadState\n  activeId: string | null\n  key: string\n  timeout?: number\n  itemToId?: ItemToId<HTMLElement>\n}\n\nfunction getByTypeaheadImpl<T extends HTMLElement>(_items: T[], options: TypeaheadOptions) {\n  const { state, activeId, key, timeout = 350, itemToId } = options\n\n  const search = state.keysSoFar + key\n  const isRepeated = search.length > 1 && Array.from(search).every((char) => char === search[0])\n\n  const query = isRepeated ? search[0] : search\n\n  let items = _items.slice()\n\n  const next = getByText(items, query, activeId, itemToId)\n\n  function cleanup() {\n    clearTimeout(state.timer)\n    state.timer = -1\n  }\n\n  function update(value: string) {\n    state.keysSoFar = value\n    cleanup()\n\n    if (value !== \"\") {\n      state.timer = +setTimeout(() => {\n        update(\"\")\n        cleanup()\n      }, timeout)\n    }\n  }\n\n  update(search)\n\n  return next\n}\nexport const getByTypeahead = /*#__PURE__*/ Object.assign(getByTypeaheadImpl, {\n  defaultOptions: { keysSoFar: \"\", timer: -1 },\n  isValidEvent: isValidTypeaheadEvent,\n})\n\nfunction isValidTypeaheadEvent(event: Pick<KeyboardEvent, \"key\" | \"ctrlKey\" | \"metaKey\">) {\n  return event.key.length === 1 && !event.ctrlKey && !event.metaKey\n}\n","import { getWindow } from \"./env\"\n\nconst styleCache = new WeakMap<Element, CSSStyleDeclaration>()\n\nexport function getComputedStyle(el: Element) {\n  if (!styleCache.has(el)) {\n    styleCache.set(el, getWindow(el).getComputedStyle(el))\n  }\n  return styleCache.get(el)!\n}\n","import { getDocumentElement } from \"./env\"\nimport { getNodeName, isShadowRoot } from \"./is\"\n\nexport function getParentNode(node: Node): Node {\n  if (getNodeName(node) === \"html\") {\n    return node\n  }\n\n  const result =\n    // Step into the shadow DOM of the parent of a slotted node.\n    (node as any).assignedSlot ||\n    // DOM Element detected.\n    node.parentNode ||\n    // ShadowRoot detected.\n    (isShadowRoot(node) && node.host) ||\n    // Fallback.\n    getDocumentElement(node)\n\n  return isShadowRoot(result) ? result.host : result\n}\n","import { isHTMLElement } from \"./is\"\n\nexport interface ScrollPosition {\n  scrollLeft: number\n  scrollTop: number\n}\n\nexport function getScrollPosition(element: HTMLElement | Window): ScrollPosition {\n  if (isHTMLElement(element)) {\n    return { scrollLeft: element.scrollLeft, scrollTop: element.scrollTop }\n  }\n  return { scrollLeft: element.scrollX, scrollTop: element.scrollY }\n}\n","const isHTMLElement = (element: any): element is HTMLElement =>\n  typeof element === \"object\" && element !== null && element.nodeType === 1\n\nconst isFrame = (element: any): element is HTMLIFrameElement => isHTMLElement(element) && element.tagName === \"IFRAME\"\n\nfunction isVisible(el: any) {\n  if (!isHTMLElement(el)) return false\n  return el.offsetWidth > 0 || el.offsetHeight > 0 || el.getClientRects().length > 0\n}\n\ntype IncludeContainerType = boolean | \"if-empty\"\n\nfunction hasNegativeTabIndex(element: Element) {\n  const tabIndex = parseInt(element.getAttribute(\"tabindex\") || \"0\", 10)\n  return tabIndex < 0\n}\n\nconst focusableSelector =\n  /*#__PURE__*/ \"input:not([type='hidden']):not([disabled]), select:not([disabled]), \" +\n  \"textarea:not([disabled]), a[href], button:not([disabled]), [tabindex], \" +\n  \"iframe, object, embed, area[href], audio[controls], video[controls], \" +\n  \"[contenteditable]:not([contenteditable='false']), details > summary:first-of-type\"\n\n/**\n * Returns the focusable elements within the element\n */\nexport const getFocusables = (\n  container: Pick<HTMLElement, \"querySelectorAll\"> | null,\n  includeContainer: IncludeContainerType = false,\n) => {\n  if (!container) return []\n  const elements = Array.from(container.querySelectorAll<HTMLElement>(focusableSelector))\n\n  const include = includeContainer == true || (includeContainer == \"if-empty\" && elements.length === 0)\n  if (include && isHTMLElement(container) && isFocusable(container)) {\n    elements.unshift(container)\n  }\n\n  const focusableElements = elements.filter(isFocusable)\n\n  focusableElements.forEach((element, i) => {\n    if (isFrame(element) && element.contentDocument) {\n      const frameBody = element.contentDocument.body\n      focusableElements.splice(i, 1, ...getFocusables(frameBody))\n    }\n  })\n\n  return focusableElements\n}\n\n/**\n * Whether this element is focusable\n */\nexport function isFocusable(element: HTMLElement | null): element is HTMLElement {\n  if (!element || element.closest(\"[inert]\")) return false\n  return element.matches(focusableSelector) && isVisible(element)\n}\n\nexport function getFirstFocusable(\n  container: HTMLElement | null,\n  includeContainer?: IncludeContainerType,\n): HTMLElement | null {\n  const [first] = getFocusables(container, includeContainer)\n  return first || null\n}\n\n/**\n * Returns the tabbable elements within the element\n */\nexport function getTabbables(container: HTMLElement | null, includeContainer?: IncludeContainerType) {\n  if (!container) return []\n  const elements = Array.from(container.querySelectorAll<HTMLElement>(focusableSelector))\n  const tabbableElements = elements.filter(isTabbable)\n\n  if (includeContainer && isTabbable(container)) {\n    tabbableElements.unshift(container)\n  }\n\n  tabbableElements.forEach((element, i) => {\n    if (isFrame(element) && element.contentDocument) {\n      const frameBody = element.contentDocument.body\n      const allFrameTabbable = getTabbables(frameBody)\n      tabbableElements.splice(i, 1, ...allFrameTabbable)\n    }\n  })\n\n  if (!tabbableElements.length && includeContainer) {\n    return elements\n  }\n\n  return tabbableElements\n}\n\n/**\n * Whether this element is tabbable\n */\nexport function isTabbable(el: HTMLElement | null): el is HTMLElement {\n  if (el != null && el.tabIndex > 0) return true\n  return isFocusable(el) && !hasNegativeTabIndex(el)\n}\n\n/**\n * Returns the first focusable element within the element\n */\nexport function getFirstTabbable(\n  container: HTMLElement | null,\n  includeContainer?: IncludeContainerType,\n): HTMLElement | null {\n  const [first] = getTabbables(container, includeContainer)\n  return first || null\n}\n\n/**\n * Returns the last focusable element within the element\n */\nexport function getLastTabbable(\n  container: HTMLElement | null,\n  includeContainer?: IncludeContainerType,\n): HTMLElement | null {\n  const elements = getTabbables(container, includeContainer)\n  return elements[elements.length - 1] || null\n}\n\n/**\n * Returns the first and last focusable elements within the element\n */\nexport function getTabbableEdges(\n  container: HTMLElement | null,\n  includeContainer?: IncludeContainerType,\n): [HTMLElement, HTMLElement] | [null, null] {\n  const elements = getTabbables(container, includeContainer)\n  const first = elements[0] || null\n  const last = elements[elements.length - 1] || null\n  return [first, last]\n}\n\n/**\n * Returns the next tabbable element after the current element\n */\nexport function getNextTabbable(container: HTMLElement | null, current?: HTMLElement | null): HTMLElement | null {\n  const tabbables = getTabbables(container)\n  const doc = container?.ownerDocument || document\n  const currentElement = current ?? (doc.activeElement as HTMLElement | null)\n  if (!currentElement) return null\n  const index = tabbables.indexOf(currentElement)\n  return tabbables[index + 1] || null\n}\n","import { getTabbableEdges, getTabbables } from \"./tabbable\"\n\nexport interface InitialFocusOptions {\n  root: HTMLElement | null\n  getInitialEl?: () => HTMLElement | null\n  enabled?: boolean\n  filter?: (el: HTMLElement) => boolean\n}\n\nexport function getInitialFocus(options: InitialFocusOptions): HTMLElement | undefined {\n  const { root, getInitialEl, filter, enabled = true } = options\n\n  if (!enabled) return\n\n  let node: HTMLElement | null | undefined = null\n\n  node ||= typeof getInitialEl === \"function\" ? getInitialEl() : getInitialEl\n  node ||= root?.querySelector<HTMLElement>(\"[data-autofocus],[autofocus]\")\n\n  if (!node) {\n    const tabbables = getTabbables(root)\n    node = filter ? tabbables.filter(filter)[0] : tabbables[0]\n  }\n\n  return node || root || undefined\n}\n\nexport function isValidTabEvent(event: Pick<KeyboardEvent, \"shiftKey\" | \"currentTarget\">): boolean {\n  const container = event.currentTarget as HTMLElement | null\n  if (!container) return false\n\n  const [firstTabbable, lastTabbable] = getTabbableEdges(container)\n  const doc = container.ownerDocument || document\n\n  if (doc.activeElement === firstTabbable && event.shiftKey) return false\n  if (doc.activeElement === lastTabbable && !event.shiftKey) return false\n  if (!firstTabbable && !lastTabbable) return false\n\n  return true\n}\n","import { getWindow } from \"./env\"\nimport { isHTMLElement } from \"./is\"\n\nexport function isEditableElement(el: HTMLElement | EventTarget | null) {\n  if (el == null || !isHTMLElement(el)) {\n    return false\n  }\n\n  try {\n    const win = getWindow(el)\n    return (\n      (el instanceof win.HTMLInputElement && el.selectionStart != null) ||\n      /(textarea|select)/.test(el.localName) ||\n      el.isContentEditable\n    )\n  } catch {\n    return false\n  }\n}\n","export function isHiddenElement(node: HTMLElement) {\n  if (node.parentElement && isHiddenElement(node.parentElement)) return true\n  return node.hidden\n}\n","import { getWindow } from \"./env\"\n\nconst OVERFLOW_RE = /auto|scroll|overlay|hidden|clip/\n\nexport function isOverflowElement(el: HTMLElement): boolean {\n  const win = getWindow(el)\n  const { overflow, overflowX, overflowY, display } = win.getComputedStyle(el)\n  return OVERFLOW_RE.test(overflow + overflowY + overflowX) && ![\"inline\", \"contents\"].includes(display)\n}\n","export function nextTick(fn: VoidFunction) {\n  const set = new Set<VoidFunction>()\n  function raf(fn: VoidFunction) {\n    const id = globalThis.requestAnimationFrame(fn)\n    set.add(() => globalThis.cancelAnimationFrame(id))\n  }\n  raf(() => raf(fn))\n  return function cleanup() {\n    set.forEach((fn) => fn())\n  }\n}\n\nexport function raf(fn: VoidFunction) {\n  const id = globalThis.requestAnimationFrame(fn)\n  return () => {\n    globalThis.cancelAnimationFrame(id)\n  }\n}\n","import { raf } from \"./raf\"\n\ntype MaybeElement = HTMLElement | null\ntype NodeOrFn = MaybeElement | (() => MaybeElement)\n\nexport interface ObserveAttributeOptions {\n  attributes: string[]\n  callback(record: MutationRecord): void\n  defer?: boolean\n}\n\nfunction observeAttributesImpl(node: MaybeElement, options: ObserveAttributeOptions) {\n  if (!node) return\n  const { attributes, callback: fn } = options\n  const win = node.ownerDocument.defaultView || window\n  const obs = new win.MutationObserver((changes) => {\n    for (const change of changes) {\n      if (change.type === \"attributes\" && change.attributeName && attributes.includes(change.attributeName)) {\n        fn(change)\n      }\n    }\n  })\n  obs.observe(node, { attributes: true, attributeFilter: attributes })\n  return () => obs.disconnect()\n}\n\nexport function observeAttributes(nodeOrFn: NodeOrFn, options: ObserveAttributeOptions) {\n  const { defer } = options\n  const func = defer ? raf : (v: any) => v()\n  const cleanups: (VoidFunction | undefined)[] = []\n  cleanups.push(\n    func(() => {\n      const node = typeof nodeOrFn === \"function\" ? nodeOrFn() : nodeOrFn\n      cleanups.push(observeAttributesImpl(node, options))\n    }),\n  )\n  return () => {\n    cleanups.forEach((fn) => fn?.())\n  }\n}\n","import { raf } from \"./raf\"\n\ntype MaybeElement = HTMLElement | null\ntype NodeOrFn = MaybeElement | (() => MaybeElement)\n\nexport interface ObserveChildrenOptions {\n  callback: MutationCallback\n  defer?: boolean\n}\n\nfunction observeChildrenImpl(node: MaybeElement, options: ObserveChildrenOptions) {\n  const { callback: fn } = options\n  if (!node) return\n  const win = node.ownerDocument.defaultView || window\n  const obs = new win.MutationObserver(fn)\n  obs.observe(node, { childList: true, subtree: true })\n  return () => obs.disconnect()\n}\n\nexport function observeChildren(nodeOrFn: NodeOrFn, options: ObserveChildrenOptions) {\n  const { defer } = options\n  const func = defer ? raf : (v: any) => v()\n  const cleanups: (VoidFunction | undefined)[] = []\n  cleanups.push(\n    func(() => {\n      const node = typeof nodeOrFn === \"function\" ? nodeOrFn() : nodeOrFn\n      cleanups.push(observeChildrenImpl(node, options))\n    }),\n  )\n  return () => {\n    cleanups.forEach((fn) => fn?.())\n  }\n}\n","import { getDocument, getWindow } from \"./env\"\nimport { getParentNode } from \"./get-parent-node\"\nimport { isHTMLElement, isRootElement, isVisualViewport } from \"./is\"\nimport { isOverflowElement } from \"./is-overflow-element\"\n\nexport type OverflowAncestor = Array<VisualViewport | Window | HTMLElement | null>\n\nexport function getNearestOverflowAncestor(el: Node): HTMLElement {\n  const parentNode = getParentNode(el)\n\n  if (isRootElement(parentNode)) {\n    return getDocument(parentNode).body\n  }\n\n  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {\n    return parentNode\n  }\n\n  return getNearestOverflowAncestor(parentNode)\n}\n\nexport function getOverflowAncestors(el: HTMLElement, list: OverflowAncestor = []): OverflowAncestor {\n  const scrollableAncestor = getNearestOverflowAncestor(el)\n  const isBody = scrollableAncestor === el.ownerDocument.body\n  const win = getWindow(scrollableAncestor)\n\n  if (isBody) {\n    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [])\n  }\n\n  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, []))\n}\n\nconst getRect = (el: HTMLElement | Window | VisualViewport) => {\n  if (isHTMLElement(el)) {\n    return el.getBoundingClientRect()\n  }\n\n  if (isVisualViewport(el)) {\n    return { top: 0, left: 0, bottom: el.height, right: el.width }\n  }\n\n  return { top: 0, left: 0, bottom: el.innerHeight, right: el.innerWidth }\n}\n\nexport function isInView(el: HTMLElement | Window | VisualViewport, ancestor: HTMLElement | Window | VisualViewport) {\n  if (!isHTMLElement(el)) return true\n\n  const ancestorRect = getRect(ancestor)\n  const elRect = el.getBoundingClientRect()\n\n  return (\n    elRect.top >= ancestorRect.top &&\n    elRect.left >= ancestorRect.left &&\n    elRect.bottom <= ancestorRect.bottom &&\n    elRect.right <= ancestorRect.right\n  )\n}\n","import { raf } from \"./raf\"\nimport { getNextTabbable, getTabbableEdges } from \"./tabbable\"\n\ntype MaybeElement = HTMLElement | null\ntype NodeOrFn = MaybeElement | (() => MaybeElement)\n\ninterface ProxyTabFocusOptions<T = MaybeElement> {\n  triggerElement?: T\n  onFocus?: (elementToFocus: HTMLElement) => void\n  defer?: boolean\n}\n\n/**\n * Proxies tab focus within a container to a reference element\n * when the container is rendered in a portal\n */\n\nfunction proxyTabFocusImpl(container: MaybeElement, options: ProxyTabFocusOptions = {}) {\n  const { triggerElement, onFocus } = options\n\n  const doc = container?.ownerDocument || document\n  const body = doc.body\n\n  function onKeyDown(event: KeyboardEvent) {\n    if (event.key !== \"Tab\") return\n\n    let elementToFocus: MaybeElement | undefined = null\n\n    // get all tabbable elements within the container\n    const [firstTabbable, lastTabbable] = getTabbableEdges(container, true)\n\n    const noTabbableElements = !firstTabbable && !lastTabbable\n\n    // if we're focused on the first tabbable element and the user tabs backwards\n    // we want to focus the reference element\n    if (event.shiftKey && (doc.activeElement === firstTabbable || noTabbableElements)) {\n      elementToFocus = triggerElement\n    } else if (!event.shiftKey && doc.activeElement === triggerElement) {\n      // if we're focused on the reference element and the user tabs forwards\n      // we want to focus the first tabbable element\n      elementToFocus = firstTabbable\n    } else if (!event.shiftKey && (doc.activeElement === lastTabbable || noTabbableElements)) {\n      // if we're focused on the last tabbable element and the user tabs forwards\n      // we want to focus the next tabbable element after the reference element\n      elementToFocus = getNextTabbable(body, triggerElement)\n    }\n\n    if (!elementToFocus) return\n\n    event.preventDefault()\n\n    if (typeof onFocus === \"function\") {\n      onFocus(elementToFocus)\n    } else {\n      elementToFocus.focus()\n    }\n  }\n\n  // listen for the tab key in the capture phase\n  doc?.addEventListener(\"keydown\", onKeyDown, true)\n\n  return () => {\n    doc?.removeEventListener(\"keydown\", onKeyDown, true)\n  }\n}\n\nexport function proxyTabFocus(container: NodeOrFn, options: ProxyTabFocusOptions<NodeOrFn>) {\n  const { defer, triggerElement, ...restOptions } = options\n  const func = defer ? raf : (v: any) => v()\n  const cleanups: (VoidFunction | undefined)[] = []\n  cleanups.push(\n    func(() => {\n      const node = typeof container === \"function\" ? container() : container\n      const trigger = typeof triggerElement === \"function\" ? triggerElement() : triggerElement\n      cleanups.push(proxyTabFocusImpl(node, { triggerElement: trigger, ...restOptions }))\n    }),\n  )\n  return () => {\n    cleanups.forEach((fn) => fn?.())\n  }\n}\n","type Root = Document | Element | null | undefined\n\nexport function queryAll<T extends Element = HTMLElement>(root: Root, selector: string) {\n  return Array.from(root?.querySelectorAll<T>(selector) ?? [])\n}\n\nexport function query<T extends Element = HTMLElement>(root: Root, selector: string) {\n  return root?.querySelector<T>(selector) ?? null\n}\n","import { getDocument } from \"./env\"\n\nexport interface ScopeContext {\n  getRootNode?(): Document | ShadowRoot | Node\n}\n\nexport function createScope<T>(methods: T) {\n  const dom = {\n    getRootNode: (ctx: ScopeContext) => (ctx.getRootNode?.() ?? document) as Document | ShadowRoot,\n    getDoc: (ctx: ScopeContext) => getDocument(dom.getRootNode(ctx)),\n    getWin: (ctx: ScopeContext) => dom.getDoc(ctx).defaultView ?? window,\n    getActiveElement: (ctx: ScopeContext) => dom.getRootNode(ctx).activeElement,\n    isActiveElement: (ctx: ScopeContext, elem: HTMLElement | null) => elem === dom.getActiveElement(ctx),\n    getById: <T extends Element = HTMLElement>(ctx: ScopeContext, id: string) =>\n      dom.getRootNode(ctx).getElementById(id) as T | null,\n    setValue: <T extends { value: string }>(elem: T | null, value: string | number | null | undefined) => {\n      if (elem == null || value == null) return\n      const valueAsString = value.toString()\n      if (elem.value === valueAsString) return\n      elem.value = value.toString()\n    },\n  }\n\n  return { ...dom, ...methods }\n}\n","import { isOverflowElement } from \"./is-overflow-element\"\n\nexport interface ScrollOptions extends ScrollIntoViewOptions {\n  rootEl: HTMLElement | null\n}\n\nfunction isScrollable(el: HTMLElement): boolean {\n  return el.scrollHeight > el.clientHeight || el.scrollWidth > el.clientWidth\n}\n\nexport function scrollIntoView(el: HTMLElement | null | undefined, options?: ScrollOptions): void {\n  const { rootEl, ...scrollOptions } = options || {}\n\n  if (!el || !rootEl) {\n    return\n  }\n\n  if (!isOverflowElement(rootEl) || !isScrollable(rootEl)) {\n    return\n  }\n\n  el.scrollIntoView(scrollOptions)\n}\n","const cleanups = new WeakMap<Element, Map<string, () => void>>()\n\nexport function set(element: Element, key: string, setup: () => () => void) {\n  if (!cleanups.has(element)) {\n    cleanups.set(element, new Map())\n  }\n\n  const elementCleanups = cleanups.get(element)!\n  const prevCleanup = elementCleanups.get(key)\n\n  if (!prevCleanup) {\n    elementCleanups.set(key, setup())\n    return () => {\n      elementCleanups.get(key)?.()\n      elementCleanups.delete(key)\n    }\n  }\n\n  const cleanup = setup()\n\n  const nextCleanup = () => {\n    cleanup()\n    prevCleanup()\n    elementCleanups.delete(key)\n  }\n\n  elementCleanups.set(key, nextCleanup)\n\n  return () => {\n    const isCurrent = elementCleanups.get(key) === nextCleanup\n    if (!isCurrent) return\n    cleanup()\n    elementCleanups.set(key, prevCleanup)\n  }\n}\n\nexport function setAttribute(element: Element, attr: string, value: string) {\n  const setup = () => {\n    const previousValue = element.getAttribute(attr)\n    element.setAttribute(attr, value)\n    return () => {\n      if (previousValue == null) {\n        element.removeAttribute(attr)\n      } else {\n        element.setAttribute(attr, previousValue)\n      }\n    }\n  }\n\n  return set(element, attr, setup)\n}\n\nexport function setProperty<T extends Element, K extends keyof T & string>(element: T, property: K, value: T[K]) {\n  const setup = () => {\n    const exists = property in element\n    const previousValue = element[property]\n    element[property] = value\n    return () => {\n      if (!exists) {\n        delete element[property]\n      } else {\n        element[property] = previousValue\n      }\n    }\n  }\n\n  return set(element, property, setup)\n}\n\nexport function setStyle(element: HTMLElement | null | undefined, style: Partial<CSSStyleDeclaration>) {\n  if (!element) return () => {}\n\n  const setup = () => {\n    const prevStyle = element.style.cssText\n    Object.assign(element.style, style)\n    return () => {\n      element.style.cssText = prevStyle\n    }\n  }\n\n  return set(element, \"style\", setup)\n}\n","export const visuallyHiddenStyle = {\n  border: \"0\",\n  clip: \"rect(0 0 0 0)\",\n  height: \"1px\",\n  margin: \"-1px\",\n  overflow: \"hidden\",\n  padding: \"0\",\n  position: \"absolute\",\n  width: \"1px\",\n  whiteSpace: \"nowrap\",\n  wordWrap: \"normal\",\n} as const\n","import { isHTMLElement } from \"./is\"\n\ntype ElementGetter = () => Element | null\n\nconst fps = 1000 / 60\n\nexport function waitForElement(query: ElementGetter, cb: (el: HTMLElement) => void) {\n  const el = query()\n\n  if (isHTMLElement(el) && el.isConnected) {\n    cb(el)\n    return () => void 0\n  } else {\n    const timerId = setInterval(() => {\n      const el = query()\n      if (isHTMLElement(el) && el.isConnected) {\n        cb(el)\n        clearInterval(timerId)\n      }\n    }, fps)\n\n    return () => clearInterval(timerId)\n  }\n}\n\nexport function waitForElements(queries: ElementGetter[], cb: (el: HTMLElement) => void) {\n  const cleanups: VoidFunction[] = []\n\n  queries?.forEach((query) => {\n    const clean = waitForElement(query, cb)\n    cleanups.push(clean)\n  })\n\n  return () => {\n    cleanups.forEach((fn) => fn())\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}